// Copyright (C) 2026 Fred Clausen
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

//! API handler functions for state-changing and read-only operations.

use std::time::{SystemTime, UNIX_EPOCH};
use zab_bid::{
    BootstrapMetadata, BootstrapResult, Command, State, TransitionResult, apply, apply_bootstrap,
    validate_area_exists, validate_bid_year_exists,
};
use zab_bid_audit::{Action, Actor, AuditEvent, Cause, StateSnapshot};
use zab_bid_domain::{
    Area, BidYear, CanonicalBidYear, Crew, DomainError, Initials, LeaveAccrualResult,
    LeaveAvailabilityResult, LeaveUsage, SeniorityData, UserType, calculate_leave_accrual,
    calculate_leave_availability,
};
use zab_bid_persistence::{OperatorData, SqlitePersistence};

use crate::auth::{AuthenticatedActor, AuthenticationService, AuthorizationService, Role};
use crate::csv_preview::{CsvRowResult, preview_csv_users as preview_csv_users_impl};
use crate::error::{ApiError, AuthError, translate_core_error, translate_domain_error};
use crate::password_policy::PasswordPolicy;
use crate::request_response::{
    AreaCompletenessInfo, BidYearCompletenessInfo, BidYearInfo, BlockingReason,
    ChangePasswordRequest, ChangePasswordResponse, CreateAreaRequest, CreateBidYearRequest,
    CreateOperatorRequest, CreateOperatorResponse, CsvImportRowResult, CsvImportRowStatus,
    CsvRowPreview, CsvRowStatus, DeleteOperatorRequest, DeleteOperatorResponse,
    DisableOperatorRequest, DisableOperatorResponse, EnableOperatorRequest, EnableOperatorResponse,
    GetActiveBidYearResponse, GetBootstrapCompletenessResponse, GetLeaveAvailabilityResponse,
    GlobalCapabilities, ImportCsvUsersRequest, ImportCsvUsersResponse, ListAreasRequest,
    ListAreasResponse, ListBidYearsResponse, ListOperatorsResponse, ListUsersResponse,
    LoginRequest, LoginResponse, OperatorCapabilities, OperatorInfo, OverrideAreaAssignmentRequest,
    OverrideAreaAssignmentResponse, OverrideBidOrderRequest, OverrideBidOrderResponse,
    OverrideBidWindowRequest, OverrideBidWindowResponse, OverrideEligibilityRequest,
    OverrideEligibilityResponse, PreviewCsvUsersRequest, PreviewCsvUsersResponse,
    RegisterUserRequest, ResetPasswordRequest, ResetPasswordResponse, SetActiveBidYearRequest,
    SetActiveBidYearResponse, SetExpectedAreaCountRequest, SetExpectedAreaCountResponse,
    SetExpectedUserCountRequest, SetExpectedUserCountResponse, TransitionToBiddingActiveRequest,
    TransitionToBiddingActiveResponse, TransitionToBiddingClosedRequest,
    TransitionToBiddingClosedResponse, TransitionToBootstrapCompleteRequest,
    TransitionToBootstrapCompleteResponse, TransitionToCanonicalizedRequest,
    TransitionToCanonicalizedResponse, UpdateUserRequest, UpdateUserResponse, UserCapabilities,
    UserInfo, WhoAmIResponse,
};
use zab_bid_persistence::PersistenceError;

/// Internal result type for user registration before ID population.
///
/// This is not an HTTP response type. The server layer must populate
/// the canonical IDs after persistence before constructing the final
/// `RegisterUserResponse`.
#[derive(Debug, Clone)]
pub struct RegisterUserResult {
    /// The bid year the user was registered for (display value).
    pub bid_year: u16,
    /// The user's initials.
    pub initials: String,
    /// The user's name.
    pub name: String,
    /// A success message.
    pub message: String,
}

/// Resolves the active bid year from persistence.
///
/// This function ensures that exactly one bid year is active.
///
/// # Arguments
///
/// * `persistence` - The persistence layer to query
///
/// # Returns
///
/// * `Ok(BidYear)` - The active bid year
/// * `Err(ApiError)` - If no active bid year exists
///
/// # Errors
///
/// Returns an error if:
/// - No active bid year is set
/// - Database query fails
fn resolve_active_bid_year(persistence: &mut SqlitePersistence) -> Result<BidYear, ApiError> {
    let year: u16 = persistence.get_active_bid_year().map_err(|e| match e {
        zab_bid_persistence::PersistenceError::NotFound(_) => {
            translate_domain_error(zab_bid_domain::DomainError::NoActiveBidYear)
        }
        _ => ApiError::Internal {
            message: format!("Failed to query active bid year: {e}"),
        },
    })?;

    Ok(BidYear::new(year))
}

/// The result of an API operation that includes both the response and the audit event.
///
/// This ensures that successful API operations always produce an audit trail.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ApiResult<T> {
    /// The API response.
    pub response: T,
    /// The audit event generated by this operation.
    pub audit_event: AuditEvent,
    /// The new state after the operation.
    pub new_state: State,
}

/// Registers a new user via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Translates the API request into a core command
/// - Applies the command to the current state
/// - Translates any errors to API errors
/// - Returns the API response with audit event on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `state` - The current system state
/// * `request` - The API request to register a user
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(ApiResult<RegisterUserResult>)` on success with internal result
/// * `Err(ApiError)` if unauthorized, the request is invalid, or a domain rule is violated
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - Any field validation fails
/// - The initials are already in use within the bid year
pub fn register_user(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
    state: &State,
    request: RegisterUserRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<ApiResult<RegisterUserResult>, ApiError> {
    // Enforce authorization before executing command
    AuthorizationService::authorize_register_user(authenticated_actor)?;

    // Resolve the active bid year from canonical state
    let bid_year: BidYear = resolve_active_bid_year(persistence)?;

    // Convert authenticated actor to audit actor with operator information
    let actor: Actor = authenticated_actor.to_audit_actor(operator);
    // Translate API request into domain types
    let initials: Initials = Initials::new(&request.initials);
    let area: Area = Area::new(&request.area);

    // Parse user type
    let user_type: UserType =
        UserType::parse(&request.user_type).map_err(translate_domain_error)?;

    // Parse optional crew
    let crew: Option<Crew> = match request.crew {
        Some(crew_num) => Some(Crew::new(crew_num).map_err(translate_domain_error)?),
        None => None,
    };

    let seniority_data: SeniorityData = SeniorityData::new(
        request.cumulative_natca_bu_date,
        request.natca_bu_date,
        request.eod_faa_date,
        request.service_computation_date,
        request.lottery_value,
    );

    // Create core command
    let command: Command = Command::RegisterUser {
        initials: initials.clone(),
        name: request.name.clone(),
        area,
        user_type,
        crew,
        seniority_data,
    };

    // Apply command via core transition
    let transition_result: TransitionResult =
        apply(metadata, state, &bid_year, command, actor, cause).map_err(translate_core_error)?;

    // Return internal result (IDs will be populated by server layer after persistence)
    let result: RegisterUserResult = RegisterUserResult {
        bid_year: bid_year.year(),
        initials: initials.value().to_string(),
        name: request.name,
        message: format!(
            "Successfully registered user '{}' for bid year {}",
            initials.value(),
            bid_year.year()
        ),
    };

    Ok(ApiResult {
        response: result,
        audit_event: transition_result.audit_event,
        new_state: transition_result.new_state,
    })
}

/// Creates a checkpoint via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a checkpoint command
/// - Applies the command to the current state
/// - Returns the transition result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `state` - The current system state
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(TransitionResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The command execution fails
pub fn checkpoint(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
    state: &State,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<TransitionResult, ApiError> {
    // Enforce authorization before executing command
    AuthorizationService::authorize_checkpoint(authenticated_actor)?;

    // Resolve the active bid year from canonical state
    let active_bid_year: BidYear = resolve_active_bid_year(persistence)?;

    // Convert authenticated actor to audit actor with operator information
    let actor: Actor = authenticated_actor.to_audit_actor(operator);

    // Create and apply checkpoint command
    let command: Command = Command::Checkpoint;
    let transition_result: TransitionResult =
        apply(metadata, state, &active_bid_year, command, actor, cause)
            .map_err(translate_core_error)?;

    Ok(transition_result)
}

/// Finalizes a round via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a finalize command
/// - Applies the command to the current state
/// - Returns the transition result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `state` - The current system state
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(TransitionResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The command execution fails
pub fn finalize(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
    state: &State,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<TransitionResult, ApiError> {
    // Enforce authorization before executing command
    AuthorizationService::authorize_finalize(authenticated_actor)?;

    // Resolve the active bid year from canonical state
    let active_bid_year: BidYear = resolve_active_bid_year(persistence)?;

    // Convert authenticated actor to audit actor with operator information
    let actor: Actor = authenticated_actor.to_audit_actor(operator);

    // Create and apply finalize command
    let command: Command = Command::Finalize;
    let transition_result: TransitionResult =
        apply(metadata, state, &active_bid_year, command, actor, cause)
            .map_err(translate_core_error)?;

    Ok(transition_result)
}

/// Rolls back to a specific event via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a rollback command
/// - Applies the command to the current state
/// - Returns the transition result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `state` - The current system state
/// * `target_event_id` - The event ID to rollback to
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(TransitionResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The command execution fails
pub fn rollback(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
    state: &State,
    target_event_id: i64,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<TransitionResult, ApiError> {
    // Enforce authorization before executing command
    AuthorizationService::authorize_rollback(authenticated_actor)?;

    // Resolve the active bid year from canonical state
    let active_bid_year: BidYear = resolve_active_bid_year(persistence)?;

    // Convert authenticated actor to audit actor with operator information
    let actor: Actor = authenticated_actor.to_audit_actor(operator);

    // Create and apply rollback command
    let command: Command = Command::RollbackToEventId { target_event_id };
    let transition_result: TransitionResult =
        apply(metadata, state, &active_bid_year, command, actor, cause)
            .map_err(translate_core_error)?;

    Ok(transition_result)
}

/// Creates a new bid year via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a `CreateBidYear` command
/// - Applies the command to the bootstrap metadata
/// - Returns the bootstrap result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `request` - The API request to create a bid year
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(BootstrapResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The bid year already exists
/// - The bid year value is invalid
pub fn create_bid_year(
    metadata: &BootstrapMetadata,
    request: &CreateBidYearRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<BootstrapResult, ApiError> {
    // Enforce authorization - only admins can create bid years
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("create_bid_year"),
            required_role: String::from("Admin"),
        });
    }

    // Convert authenticated actor to audit actor with operator information
    let actor: Actor = authenticated_actor.to_audit_actor(operator);

    // Create command with canonical metadata
    let command: Command = Command::CreateBidYear {
        year: request.year,
        start_date: request.start_date,
        num_pay_periods: request.num_pay_periods,
    };

    // Apply command via core bootstrap
    // Create a placeholder bid year for CreateBidYear command (it doesn't need an active bid year)
    let placeholder_bid_year = BidYear::new(request.year);
    let bootstrap_result: BootstrapResult =
        apply_bootstrap(metadata, &placeholder_bid_year, command, actor, cause)
            .map_err(translate_core_error)?;

    Ok(bootstrap_result)
}

/// Creates a new area via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a `CreateArea` command
/// - Applies the command to the bootstrap metadata
/// - Returns the bootstrap result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `request` - The API request to create an area
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(BootstrapResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The bid year does not exist
/// - The area already exists in the bid year
pub fn create_area(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
    request: &CreateAreaRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<BootstrapResult, ApiError> {
    // Enforce authorization - only admins can create areas
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("create_area"),
            required_role: String::from("Admin"),
        });
    }

    // Resolve the active bid year from canonical state
    let active_bid_year: BidYear = resolve_active_bid_year(persistence)?;

    // Convert authenticated actor to audit actor with operator information
    let actor: Actor = authenticated_actor.to_audit_actor(operator);

    // Create command
    let command: Command = Command::CreateArea {
        area_id: request.area_id.clone(),
    };

    // Apply command via core bootstrap
    let bootstrap_result: BootstrapResult =
        apply_bootstrap(metadata, &active_bid_year, command, actor, cause)
            .map_err(translate_core_error)?;

    Ok(bootstrap_result)
}

/// Lists all bid years with their canonical metadata.
///
/// This operation never fails and requires no authorization.
/// Returns an empty list if no bid years have been created.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `metadata` - The current bootstrap metadata with bid year IDs
/// * `canonical_bid_years` - The list of canonical bid years from persistence
///
/// # Returns
///
/// A response containing all bid years with canonical metadata and IDs.
///
/// # Errors
///
/// Returns an error if end date derivation fails due to date arithmetic overflow.
pub fn list_bid_years(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
    canonical_bid_years: &[CanonicalBidYear],
) -> Result<ListBidYearsResponse, ApiError> {
    let bid_years: Result<Vec<BidYearInfo>, ApiError> = canonical_bid_years
        .iter()
        .map(|c| {
            let end_date: time::Date = c.end_date().map_err(translate_domain_error)?;

            // Extract bid_year_id from metadata by matching the year
            let bid_year_id: i64 = metadata
                .bid_years
                .iter()
                .find(|by| by.year() == c.year())
                .and_then(zab_bid_domain::BidYear::bid_year_id)
                .ok_or_else(|| ApiError::Internal {
                    message: format!(
                        "Bid year {} exists in canonical data but has no ID in metadata",
                        c.year()
                    ),
                })?;

            // Fetch lifecycle state from persistence
            let lifecycle_state: String = persistence
                .get_lifecycle_state(bid_year_id)
                .unwrap_or_else(|_| String::from("Draft"));

            Ok(BidYearInfo {
                bid_year_id,
                year: c.year(),
                start_date: c.start_date(),
                num_pay_periods: c.num_pay_periods(),
                end_date,
                area_count: 0,       // Will be populated by server layer
                total_user_count: 0, // Will be populated by server layer
                lifecycle_state,
            })
        })
        .collect();

    Ok(ListBidYearsResponse {
        bid_years: bid_years?,
    })
}

/// Lists all areas for a given bid year.
///
/// This is a read-only operation that requires no authorization.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `request` - The list areas request
///
/// # Returns
///
/// * `Ok(ListAreasResponse)` containing all areas for the bid year
/// * `Err(ApiError)` if the bid year does not exist
///
/// # Errors
///
/// Returns an error if the bid year has not been created.
pub fn list_areas(
    metadata: &BootstrapMetadata,
    request: &ListAreasRequest,
) -> Result<ListAreasResponse, ApiError> {
    // Resolve bid_year_id to BidYear from metadata
    let bid_year: &BidYear = metadata
        .bid_years
        .iter()
        .find(|by| by.bid_year_id() == Some(request.bid_year_id))
        .ok_or_else(|| ApiError::ResourceNotFound {
            resource_type: String::from("BidYear"),
            message: format!("Bid year with ID {} not found", request.bid_year_id),
        })?;

    let areas: Vec<crate::request_response::AreaInfo> = metadata
        .areas
        .iter()
        .filter(|(by, _)| by.year() == bid_year.year())
        .map(|(_, area)| {
            // Extract area_id - all persisted areas must have IDs
            let area_id: i64 = area.area_id().ok_or_else(|| ApiError::Internal {
                message: format!(
                    "Area '{}' in bid year {} has no ID",
                    area.area_code(),
                    bid_year.year()
                ),
            })?;

            Ok(crate::request_response::AreaInfo {
                area_id,
                area_code: area.area_code().to_string(),
                area_name: area.area_name().map(String::from),
                user_count: 0, // Will be populated by server layer with actual counts
            })
        })
        .collect::<Result<Vec<_>, ApiError>>()?;

    Ok(ListAreasResponse {
        bid_year_id: request.bid_year_id,
        bid_year: bid_year.year(),
        areas,
    })
}

/// Lists all users in a given bid year and area with leave balances and capabilities.
///
/// This is a read-only operation. No authorization check is performed.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `canonical_bid_years` - The list of canonical bid years
/// * `bid_year` - The bid year to list users for
/// * `area` - The area to list users for
/// * `state` - The current state for this scope
/// * `authenticated_actor` - The authenticated actor (for capability computation)
/// * `actor_operator` - The authenticated operator's data (for capability computation)
///
/// # Returns
///
/// * `Ok(ListUsersResponse)` containing all users for the scope with capabilities
/// * `Err(ApiError)` if the bid year or area does not exist
///
/// # Errors
///
/// Returns an error if:
/// - The bid year has not been created
/// - The area has not been created in the bid year
pub fn list_users(
    metadata: &BootstrapMetadata,
    canonical_bid_years: &[CanonicalBidYear],
    bid_year: &BidYear,
    area: &Area,
    state: &State,
    authenticated_actor: &AuthenticatedActor,
    actor_operator: &OperatorData,
) -> Result<ListUsersResponse, ApiError> {
    // Validate bid year and area exist before processing
    validate_area_exists(metadata, bid_year, area).map_err(translate_domain_error)?;

    // Extract bid_year_id from metadata
    let bid_year_id: i64 = metadata
        .bid_years
        .iter()
        .find(|by| by.year() == bid_year.year())
        .and_then(zab_bid_domain::BidYear::bid_year_id)
        .ok_or_else(|| ApiError::Internal {
            message: format!(
                "Bid year {} exists but has no ID in metadata",
                bid_year.year()
            ),
        })?;

    // Extract area_id from metadata
    let area_id: i64 = metadata
        .areas
        .iter()
        .filter(|(by, _)| by.year() == bid_year.year())
        .find(|(_, a)| a.area_code() == area.id())
        .and_then(|(_, a)| a.area_id())
        .ok_or_else(|| ApiError::Internal {
            message: format!(
                "Area '{}' in bid year {} exists but has no ID in metadata",
                area.id(),
                bid_year.year()
            ),
        })?;

    // Find the canonical bid year metadata for leave calculations
    let canonical_bid_year: &CanonicalBidYear = canonical_bid_years
        .iter()
        .find(|c| c.year() == bid_year.year())
        .ok_or_else(|| {
            translate_domain_error(zab_bid_domain::DomainError::InvalidBidYear(format!(
                "Bid year {} not found",
                bid_year.year()
            )))
        })?;

    let users: Result<Vec<UserInfo>, ApiError> = state
        .users
        .iter()
        .map(|user| {
            // Verify user_id is present (data integrity check)
            let user_id: i64 = user.user_id.ok_or_else(|| ApiError::Internal {
                message: format!(
                    "User '{}' loaded from database is missing user_id (data integrity violation)",
                    user.initials.value()
                ),
            })?;

            // Calculate leave accrual for this user
            let leave_accrual_result: LeaveAccrualResult =
                calculate_leave_accrual(user, canonical_bid_year).unwrap_or_else(|_| {
                    LeaveAccrualResult {
                        total_hours: 0,
                        total_days: 0,
                        rounded_up: false,
                        breakdown: vec![],
                    }
                });

            let earned_hours: u16 = leave_accrual_result.total_hours;
            let earned_days: u16 = leave_accrual_result.total_days;

            // Calculate availability
            // For Phase 11, we don't have bid records yet, so usage is empty
            let availability: LeaveAvailabilityResult =
                calculate_leave_availability(&leave_accrual_result, std::iter::empty())
                    .unwrap_or_else(|_| LeaveAvailabilityResult {
                        earned_hours,
                        earned_days,
                        used_hours: 0,
                        remaining_hours: i32::from(earned_hours),
                        remaining_days: i32::from(earned_days),
                        is_exhausted: false,
                        is_overdrawn: false,
                    });

            // Compute user capabilities
            let capabilities: UserCapabilities =
                crate::capabilities::compute_user_capabilities(authenticated_actor, actor_operator)
                    .map_err(|e| ApiError::Internal {
                        message: format!("Failed to compute user capabilities: {e}"),
                    })?;

            Ok(UserInfo {
                user_id,
                bid_year_id,
                area_id,
                initials: user.initials.value().to_string(),
                name: user.name.clone(),
                crew: user.crew.as_ref().map(Crew::number),
                user_type: user.user_type.as_str().to_string(),
                earned_hours,
                earned_days,
                remaining_hours: availability.remaining_hours,
                remaining_days: availability.remaining_days,
                is_exhausted: availability.is_exhausted,
                is_overdrawn: availability.is_overdrawn,
                capabilities,
            })
        })
        .collect();

    Ok(ListUsersResponse {
        bid_year_id,
        bid_year: state.bid_year.year(),
        area_id,
        area_code: state.area.id().to_string(),
        users: users?,
    })
}

/// Gets the current state for a given bid year and area.
///
/// This is a read-only operation that requires no authorization.
/// This function validates that the bid year and area exist before
/// attempting to load state from persistence.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `bid_year` - The bid year to get state for
/// * `area` - The area to get state for
/// * `state` - The current state (if it exists)
///
/// # Returns
///
/// * `Ok(State)` - The current state for the scope
/// * `Err(ApiError)` if the bid year or area does not exist
///
/// # Errors
///
/// Returns an error if:
/// - The bid year has not been created
/// - The area has not been created in the bid year
pub fn get_current_state(
    metadata: &BootstrapMetadata,
    bid_year: &BidYear,
    area: &Area,
    state: State,
) -> Result<State, ApiError> {
    // Validate bid year and area exist before returning state
    validate_area_exists(metadata, bid_year, area).map_err(translate_domain_error)?;

    Ok(state)
}

/// Gets the historical state for a given bid year and area at a specific timestamp.
///
/// This is a read-only operation that requires no authorization.
/// This function validates that the bid year and area exist before
/// attempting to load historical state from persistence.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `bid_year` - The bid year to get state for
/// * `area` - The area to get state for
/// * `state` - The historical state (if it exists)
///
/// # Returns
///
/// * `Ok(State)` - The historical state for the scope at the timestamp
/// * `Err(ApiError)` if the bid year or area does not exist
///
/// # Errors
///
/// Returns an error if:
/// - The bid year has not been created
/// - The area has not been created in the bid year
pub fn get_historical_state(
    metadata: &BootstrapMetadata,
    bid_year: &BidYear,
    area: &Area,
    state: State,
) -> Result<State, ApiError> {
    // Validate bid year and area exist before returning state
    validate_area_exists(metadata, bid_year, area).map_err(translate_domain_error)?;

    Ok(state)
}

/// Gets leave availability for a specific user.
///
/// This is a read-only operation that:
/// - Validates the bid year and area exist
/// - Finds the specified user
/// - Calculates leave accrual using Phase 9 logic
/// - Retrieves leave usage records (currently none exist in persistence)
/// - Calculates remaining leave availability
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `canonical_bid_year` - The canonical bid year for accrual calculation
/// * `area` - The area
/// * `initials` - The user's initials
/// * `state` - The current state
///
/// # Returns
///
/// * `Ok(GetLeaveAvailabilityResponse)` - The leave availability information
/// * `Err(ApiError)` if the bid year, area, or user does not exist
///
/// # Errors
///
/// Returns an error if:
/// - The bid year does not exist
/// - The area does not exist in the bid year
/// - The user does not exist in the area
/// - Leave accrual calculation fails
/// - Leave availability calculation fails
pub fn get_leave_availability(
    metadata: &BootstrapMetadata,
    canonical_bid_year: &CanonicalBidYear,
    area: &Area,
    initials: &Initials,
    state: &State,
) -> Result<GetLeaveAvailabilityResponse, ApiError> {
    let bid_year: BidYear = BidYear::new(canonical_bid_year.year());

    // Validate bid year and area exist
    validate_area_exists(metadata, &bid_year, area).map_err(translate_domain_error)?;

    // Extract bid_year_id from metadata
    let bid_year_id: i64 = metadata
        .bid_years
        .iter()
        .find(|by| by.year() == bid_year.year())
        .and_then(zab_bid_domain::BidYear::bid_year_id)
        .ok_or_else(|| ApiError::Internal {
            message: format!(
                "Bid year {} exists but has no ID in metadata",
                bid_year.year()
            ),
        })?;

    // Find the user
    let user = state
        .users
        .iter()
        .find(|u| u.initials == *initials)
        .ok_or_else(|| ApiError::ResourceNotFound {
            resource_type: String::from("User"),
            message: format!(
                "User with initials '{}' not found in bid year {} area {}",
                initials.value(),
                bid_year.year(),
                area.id()
            ),
        })?;

    // Verify user_id is present (data integrity check)
    let user_id: i64 = user.user_id.ok_or_else(|| ApiError::Internal {
        message: format!(
            "User '{}' loaded from database is missing user_id (data integrity violation)",
            user.initials.value()
        ),
    })?;

    // Calculate leave accrual using Phase 9
    let accrual =
        calculate_leave_accrual(user, canonical_bid_year).map_err(translate_domain_error)?;

    // Retrieve leave usage records
    // Note: For Phase 10, no persistence for leave usage exists yet.
    // We pass an empty iterator, which means all earned leave is available.
    let usage_records: Vec<LeaveUsage> = Vec::new();

    // Calculate leave availability
    let availability: LeaveAvailabilityResult =
        calculate_leave_availability(&accrual, usage_records).map_err(translate_domain_error)?;

    // Build explanation
    let explanation: String = format!(
        "Leave accrual calculated for user '{}' in bid year {}. \
         Earned: {} hours ({} days). Used: {} hours. \
         Remaining: {} hours ({} days).{}{}",
        initials.value(),
        bid_year.year(),
        availability.earned_hours,
        availability.earned_days,
        availability.used_hours,
        availability.remaining_hours,
        availability.remaining_days,
        if availability.is_exhausted {
            " Leave fully exhausted."
        } else {
            ""
        },
        if availability.is_overdrawn {
            " Leave balance is overdrawn."
        } else {
            ""
        }
    );

    Ok(GetLeaveAvailabilityResponse {
        bid_year_id,
        bid_year: bid_year.year(),
        user_id,
        initials: initials.value().to_string(),
        earned_hours: availability.earned_hours,
        earned_days: availability.earned_days,
        used_hours: availability.used_hours,
        remaining_hours: availability.remaining_hours,
        remaining_days: availability.remaining_days,
        is_exhausted: availability.is_exhausted,
        is_overdrawn: availability.is_overdrawn,
        explanation,
    })
}

/// Gets a comprehensive bootstrap status summary.
///
/// This is a read-only operation that provides aggregated information
/// about all bid years and areas in the system.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `area_counts` - Area counts per bid year
/// * `user_counts_by_year` - Total user counts per bid year
/// * `user_counts_by_area` - User counts per (`bid_year`, `area_id`)
///
/// # Returns
///
/// * `Ok(BootstrapStatusResponse)` containing all system status information
///
/// # Errors
///
/// This function does not currently return errors, but the return type supports
/// future error conditions.
///
/// This endpoint is useful for operators to get a complete picture of the
/// system state in a single API call.
pub fn get_bootstrap_status(
    metadata: &BootstrapMetadata,
    area_counts: &[(u16, usize)],
    user_counts_by_year: &[(u16, usize)],
    user_counts_by_area: &[(u16, String, usize)],
) -> Result<crate::request_response::BootstrapStatusResponse, ApiError> {
    use crate::request_response::{AreaStatusInfo, BidYearStatusInfo, BootstrapStatusResponse};

    // Build bid year summaries
    let bid_years: Vec<BidYearStatusInfo> = metadata
        .bid_years
        .iter()
        .map(|bid_year| {
            let year: u16 = bid_year.year();
            let bid_year_id: i64 = bid_year.bid_year_id().ok_or_else(|| ApiError::Internal {
                message: format!("Bid year {year} has no ID in metadata"),
            })?;
            let area_count: usize = area_counts
                .iter()
                .find(|(y, _)| *y == year)
                .map_or(0, |(_, count)| *count);
            let total_user_count: usize = user_counts_by_year
                .iter()
                .find(|(y, _)| *y == year)
                .map_or(0, |(_, count)| *count);

            Ok(BidYearStatusInfo {
                bid_year_id,
                year,
                area_count,
                total_user_count,
            })
        })
        .collect::<Result<Vec<_>, ApiError>>()?;

    // Build area summaries
    let areas: Vec<AreaStatusInfo> = metadata
        .areas
        .iter()
        .map(|(bid_year, area)| {
            let year: u16 = bid_year.year();
            let bid_year_id: i64 = metadata
                .bid_years
                .iter()
                .find(|by| by.year() == year)
                .and_then(zab_bid_domain::BidYear::bid_year_id)
                .ok_or_else(|| ApiError::Internal {
                    message: format!("Bid year {year} has no ID in metadata"),
                })?;
            let area_code: String = area.area_code().to_string();
            let area_id: i64 = area.area_id().ok_or_else(|| ApiError::Internal {
                message: format!("Area '{area_code}' in bid year {year} has no ID in metadata"),
            })?;
            let user_count: usize = user_counts_by_area
                .iter()
                .find(|(y, a, _)| *y == year && a == &area_code)
                .map_or(0, |(_, _, count)| *count);

            Ok(AreaStatusInfo {
                bid_year_id,
                bid_year: year,
                area_id,
                area_code,
                user_count,
            })
        })
        .collect::<Result<Vec<_>, ApiError>>()?;

    Ok(BootstrapStatusResponse { bid_years, areas })
}

// ========================================================================
// Authentication Handlers (Phase 14)
// ========================================================================

/// Authenticates an operator and creates a session.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The login request
///
/// # Returns
///
/// * `Ok(LoginResponse)` on success with session token
/// * `Err(ApiError)` if authentication fails
///
/// # Errors
///
/// Returns an error if:
/// - The operator does not exist
/// - The operator is disabled
/// - Database operations fail
pub fn login(
    persistence: &mut SqlitePersistence,
    request: &LoginRequest,
) -> Result<LoginResponse, ApiError> {
    let (session_token, _authenticated_actor, operator): (
        String,
        AuthenticatedActor,
        OperatorData,
    ) = AuthenticationService::login(persistence, &request.login_name, &request.password)?;

    // Get session expiration from the session we just created
    let session: Option<zab_bid_persistence::SessionData> = persistence
        .get_session_by_token(&session_token)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to retrieve session: {e}"),
        })?;

    let expires_at: String = session
        .ok_or_else(|| ApiError::Internal {
            message: String::from("Session not found after creation"),
        })?
        .expires_at;

    Ok(LoginResponse {
        session_token,
        login_name: operator.login_name,
        display_name: operator.display_name,
        role: operator.role,
        expires_at,
    })
}

/// Logs out by deleting the session.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `session_token` - The session token to delete
///
/// # Errors
///
/// Returns an error if the logout fails.
pub fn logout(persistence: &mut SqlitePersistence, session_token: &str) -> Result<(), ApiError> {
    AuthenticationService::logout(persistence, session_token)?;
    Ok(())
}

/// Returns the current operator's information with global capabilities.
///
/// # Arguments
///
/// * `persistence` - The persistence layer (for computing capabilities)
/// * `actor` - The authenticated actor
/// * `operator` - The operator data from the validated session
///
/// # Returns
///
/// * `Ok(WhoAmIResponse)` with operator information and capabilities
///
/// # Errors
///
/// Returns an error if capability computation fails.
pub fn whoami(
    _persistence: &mut SqlitePersistence,
    actor: &AuthenticatedActor,
    operator: &OperatorData,
) -> Result<WhoAmIResponse, ApiError> {
    let capabilities: GlobalCapabilities =
        crate::capabilities::compute_global_capabilities(actor, operator).map_err(|e| {
            ApiError::Internal {
                message: format!("Failed to compute global capabilities: {e}"),
            }
        })?;

    Ok(WhoAmIResponse {
        login_name: operator.login_name.clone(),
        display_name: operator.display_name.clone(),
        role: operator.role.clone(),
        is_disabled: operator.is_disabled,
        capabilities,
    })
}

/// Creates a new operator.
///
/// Only Admin actors may create operators.
/// Emits an audit event on success.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The create operator request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data for audit attribution
/// * `cause` - The cause for this action
///
/// # Returns
///
/// * `Ok(CreateOperatorResponse)` on success
/// * `Err(ApiError)` if unauthorized or creation fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The login name already exists
/// - The role is invalid
/// - Database operations fail
pub fn create_operator(
    persistence: &mut SqlitePersistence,
    request: CreateOperatorRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<CreateOperatorResponse, ApiError> {
    // Enforce authorization before executing command
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("create_operator"),
            required_role: String::from("Admin"),
        });
    }

    // Validate role
    if request.role != "Admin" && request.role != "Bidder" {
        return Err(ApiError::InvalidInput {
            field: String::from("role"),
            message: format!(
                "Invalid role: {}. Must be 'Admin' or 'Bidder'",
                request.role
            ),
        });
    }

    // Validate password policy
    let policy: PasswordPolicy = PasswordPolicy::default();
    policy.validate(
        &request.password,
        &request.password_confirmation,
        &request.login_name,
        &request.display_name,
    )?;

    // Create operator with validated password
    let operator_id: i64 = persistence
        .create_operator(
            &request.login_name,
            &request.display_name,
            &request.password,
            &request.role,
        )
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to create operator: {e}"),
        })?;

    // Create audit event for operator lifecycle change
    let actor: Actor = Actor::with_operator(
        operator.operator_id.to_string(),
        String::from("operator"),
        operator.operator_id,
        operator.login_name.clone(),
        operator.display_name.clone(),
    );

    let action: Action = Action::new(
        String::from("CreateOperator"),
        Some(format!(
            "Created operator {} ({}) with role {}",
            request.login_name, request.display_name, request.role
        )),
    );

    let before: StateSnapshot = StateSnapshot::new(String::from("operator_does_not_exist"));
    let after: StateSnapshot = StateSnapshot::new(format!(
        "operator_id={},login_name={},role={}",
        operator_id, request.login_name, request.role
    ));

    // Phase 23B: Use global event for operator management
    let audit_event: AuditEvent = AuditEvent::new_global(actor, cause, action, before, after);

    // Persist audit event
    persistence
        .persist_audit_event(&audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    Ok(CreateOperatorResponse {
        operator_id,
        login_name: request.login_name,
        display_name: request.display_name,
        role: request.role,
    })
}

/// Lists all operators with per-operator capabilities.
///
/// Only Admin actors may list operators.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `actor_operator` - The authenticated operator's data
///
/// # Returns
///
/// * `Ok(ListOperatorsResponse)` with the list of operators and their capabilities
/// * `Err(ApiError)` if unauthorized or query fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - Database operations fail
pub fn list_operators(
    persistence: &mut SqlitePersistence,
    authenticated_actor: &AuthenticatedActor,
    actor_operator: &OperatorData,
) -> Result<ListOperatorsResponse, ApiError> {
    // Enforce authorization before executing command
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("list_operators"),
            required_role: String::from("Admin"),
        });
    }

    let operators: Vec<OperatorData> =
        persistence
            .list_operators()
            .map_err(|e| ApiError::Internal {
                message: format!("Failed to list operators: {e}"),
            })?;

    let operator_infos: Result<Vec<OperatorInfo>, ApiError> = operators
        .into_iter()
        .map(|op| {
            let capabilities: OperatorCapabilities =
                crate::capabilities::compute_operator_capabilities(
                    authenticated_actor,
                    actor_operator,
                    &op,
                    persistence,
                )
                .map_err(|e| ApiError::Internal {
                    message: format!("Failed to compute operator capabilities: {e}"),
                })?;

            Ok(OperatorInfo {
                operator_id: op.operator_id,
                login_name: op.login_name,
                display_name: op.display_name,
                role: op.role,
                is_disabled: op.is_disabled,
                created_at: op.created_at,
                last_login_at: op.last_login_at,
                capabilities,
            })
        })
        .collect();

    Ok(ListOperatorsResponse {
        operators: operator_infos?,
    })
}

/// Disables an operator.
///
/// Only Admin actors may disable operators.
/// Emits an audit event on success.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The disable operator request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data for audit attribution
/// * `cause` - The cause for this action
///
/// # Returns
///
/// * `Ok(DisableOperatorResponse)` on success
/// * `Err(ApiError)` if unauthorized or operation fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The operator does not exist
/// - Database operations fail
pub fn disable_operator(
    persistence: &mut SqlitePersistence,
    request: DisableOperatorRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<DisableOperatorResponse, ApiError> {
    // Enforce authorization before executing command
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("disable_operator"),
            required_role: String::from("Admin"),
        });
    }

    // Get target operator to verify existence and get details for audit
    let target_operator: OperatorData = persistence
        .get_operator_by_id(request.operator_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to get operator: {e}"),
        })?
        .ok_or_else(|| {
            let operator_id = request.operator_id;
            ApiError::ResourceNotFound {
                resource_type: String::from("Operator"),
                message: format!("Operator with ID {operator_id} not found"),
            }
        })?;

    // Enforce invariant: cannot disable the last active admin
    // Only check if the target is an active admin
    if target_operator.role == "Admin" && !target_operator.is_disabled {
        let active_admin_count: i64 =
            persistence
                .count_active_admin_operators()
                .map_err(|e| ApiError::Internal {
                    message: format!("Failed to count active admins: {e}"),
                })?;

        if active_admin_count <= 1 {
            return Err(ApiError::DomainRuleViolation {
                rule: String::from("last_active_admin"),
                message: String::from("Operation would leave the system without an active admin"),
            });
        }
    }

    // Perform the disable operation
    persistence
        .disable_operator(request.operator_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to disable operator: {e}"),
        })?;

    // Create audit event for operator lifecycle change
    let actor: Actor = Actor::with_operator(
        operator.operator_id.to_string(),
        String::from("operator"),
        operator.operator_id,
        operator.login_name.clone(),
        operator.display_name.clone(),
    );

    let action: Action = Action::new(
        String::from("DisableOperator"),
        Some(format!(
            "Disabled operator {} ({})",
            target_operator.login_name, target_operator.display_name
        )),
    );

    let operator_id = request.operator_id;
    let before: StateSnapshot =
        StateSnapshot::new(format!("operator_id={operator_id},is_disabled=false"));
    let after: StateSnapshot =
        StateSnapshot::new(format!("operator_id={operator_id},is_disabled=true"));

    // Phase 23B: Use global event for operator management
    let audit_event: AuditEvent = AuditEvent::new_global(actor, cause, action, before, after);

    // Persist audit event
    persistence
        .persist_audit_event(&audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    let login_name = &target_operator.login_name;
    Ok(DisableOperatorResponse {
        message: format!("Operator {login_name} has been disabled"),
    })
}

/// Re-enables a disabled operator.
///
/// Only Admin actors may re-enable operators.
/// Emits an audit event on success.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The enable operator request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data for audit attribution
/// * `cause` - The cause for this action
///
/// # Returns
///
/// * `Ok(EnableOperatorResponse)` on success
/// * `Err(ApiError)` if unauthorized or operation fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The operator does not exist
/// - Database operations fail
pub fn enable_operator(
    persistence: &mut SqlitePersistence,
    request: EnableOperatorRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<EnableOperatorResponse, ApiError> {
    // Enforce authorization before executing command
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("enable_operator"),
            required_role: String::from("Admin"),
        });
    }

    // Get target operator to verify existence and get details for audit
    let target_operator: OperatorData = persistence
        .get_operator_by_id(request.operator_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to get operator: {e}"),
        })?
        .ok_or_else(|| {
            let operator_id = request.operator_id;
            ApiError::ResourceNotFound {
                resource_type: String::from("Operator"),
                message: format!("Operator with ID {operator_id} not found"),
            }
        })?;

    // Perform the enable operation
    persistence
        .enable_operator(request.operator_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to enable operator: {e}"),
        })?;

    // Create audit event for operator lifecycle change
    let actor: Actor = Actor::with_operator(
        operator.operator_id.to_string(),
        String::from("operator"),
        operator.operator_id,
        operator.login_name.clone(),
        operator.display_name.clone(),
    );

    let action: Action = Action::new(
        String::from("EnableOperator"),
        Some(format!(
            "Re-enabled operator {} ({})",
            target_operator.login_name, target_operator.display_name
        )),
    );

    let operator_id = request.operator_id;
    let before: StateSnapshot =
        StateSnapshot::new(format!("operator_id={operator_id},is_disabled=true"));
    let after: StateSnapshot =
        StateSnapshot::new(format!("operator_id={operator_id},is_disabled=false"));

    // Phase 23B: Use global event for operator management
    let audit_event: AuditEvent = AuditEvent::new_global(actor, cause, action, before, after);

    // Persist audit event
    persistence
        .persist_audit_event(&audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    let login_name = &target_operator.login_name;
    Ok(EnableOperatorResponse {
        message: format!("Operator {login_name} has been re-enabled"),
    })
}

/// Deletes an operator.
///
/// Only Admin actors may delete operators.
/// Operators can only be deleted if they are not referenced by any audit events.
/// Emits an audit event on success.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The delete operator request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data for audit attribution
/// * `cause` - The cause for this action
///
/// # Returns
///
/// * `Ok(DeleteOperatorResponse)` on success
/// * `Err(ApiError)` if unauthorized, operator is referenced, or operation fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The operator does not exist
/// - The operator is referenced by audit events
/// - Database operations fail
pub fn delete_operator(
    persistence: &mut SqlitePersistence,
    request: DeleteOperatorRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<DeleteOperatorResponse, ApiError> {
    // Enforce authorization before executing command
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("delete_operator"),
            required_role: String::from("Admin"),
        });
    }

    // Get target operator to verify existence and get details for audit
    let target_operator: OperatorData = persistence
        .get_operator_by_id(request.operator_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to get operator: {e}"),
        })?
        .ok_or_else(|| {
            let operator_id = request.operator_id;
            ApiError::ResourceNotFound {
                resource_type: String::from("Operator"),
                message: format!("Operator with ID {operator_id} not found"),
            }
        })?;

    // Enforce invariant: cannot delete the last active admin
    // Only check if the target is an active admin
    if target_operator.role == "Admin" && !target_operator.is_disabled {
        let active_admin_count: i64 =
            persistence
                .count_active_admin_operators()
                .map_err(|e| ApiError::Internal {
                    message: format!("Failed to count active admins: {e}"),
                })?;

        if active_admin_count <= 1 {
            return Err(ApiError::DomainRuleViolation {
                rule: String::from("last_active_admin"),
                message: String::from("Operation would leave the system without an active admin"),
            });
        }
    }

    // Perform the delete operation (will fail if operator is referenced)
    persistence
        .delete_operator(request.operator_id)
        .map_err(|e| match e {
            PersistenceError::OperatorReferenced { operator_id } => ApiError::DomainRuleViolation {
                rule: String::from("operator_not_referenced"),
                message: format!(
                    "Cannot delete operator {operator_id}: referenced by audit events"
                ),
            },
            _ => ApiError::Internal {
                message: format!("Failed to delete operator: {e}"),
            },
        })?;

    // Create audit event for operator lifecycle change
    let actor: Actor = Actor::with_operator(
        operator.operator_id.to_string(),
        String::from("operator"),
        operator.operator_id,
        operator.login_name.clone(),
        operator.display_name.clone(),
    );

    let action: Action = Action::new(
        String::from("DeleteOperator"),
        Some(format!(
            "Deleted operator {} ({})",
            target_operator.login_name, target_operator.display_name
        )),
    );

    let operator_id = request.operator_id;
    let login_name = &target_operator.login_name;
    let before: StateSnapshot =
        StateSnapshot::new(format!("operator_id={operator_id},login_name={login_name}"));
    let after: StateSnapshot = StateSnapshot::new(String::from("operator_deleted"));

    // Phase 23B: Use global event for operator management
    let audit_event: AuditEvent = AuditEvent::new_global(actor, cause, action, before, after);

    // Persist audit event
    persistence
        .persist_audit_event(&audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    let login_name = &target_operator.login_name;
    Ok(DeleteOperatorResponse {
        message: format!("Operator {login_name} has been deleted"),
    })
}

/// Changes an operator's own password.
///
/// Any authenticated operator may change their own password.
/// Validates the current password, enforces password policy, and invalidates all sessions.
/// Emits an audit event on success.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The change password request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data for audit attribution
/// * `cause` - The cause for this action
///
/// # Returns
///
/// * `Ok(ChangePasswordResponse)` on success
/// * `Err(ApiError)` if validation fails or operation fails
///
/// # Errors
///
/// Returns an error if:
/// - Current password is incorrect
/// - New password does not meet policy requirements
/// - Password confirmation does not match
/// - Database operations fail
pub fn change_password(
    persistence: &mut SqlitePersistence,
    request: &ChangePasswordRequest,
    _authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<ChangePasswordResponse, ApiError> {
    // Verify current password
    let password_valid: bool = persistence
        .verify_password(&request.current_password, &operator.password_hash)
        .map_err(|e| ApiError::Internal {
            message: format!("Password verification failed: {e}"),
        })?;

    if !password_valid {
        return Err(ApiError::AuthenticationFailed {
            reason: String::from("Current password is incorrect"),
        });
    }

    // Validate new password policy
    let policy: PasswordPolicy = PasswordPolicy::default();
    policy.validate(
        &request.new_password,
        &request.new_password_confirmation,
        &operator.login_name,
        &operator.display_name,
    )?;

    // Update password
    persistence
        .update_password(operator.operator_id, &request.new_password)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to update password: {e}"),
        })?;

    // Invalidate all sessions for this operator
    persistence
        .delete_sessions_for_operator(operator.operator_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to invalidate sessions: {e}"),
        })?;

    // Create audit event for password change
    let actor: Actor = Actor::with_operator(
        operator.operator_id.to_string(),
        String::from("operator"),
        operator.operator_id,
        operator.login_name.clone(),
        operator.display_name.clone(),
    );

    let action: Action = Action::new(
        String::from("ChangePassword"),
        Some(format!(
            "Operator {} changed their own password",
            operator.login_name
        )),
    );

    let operator_id = operator.operator_id;
    let before: StateSnapshot = StateSnapshot::new(format!("operator_id={operator_id}"));
    let after: StateSnapshot =
        StateSnapshot::new(format!("operator_id={operator_id},password_changed"));

    // Phase 23B: Use global event for operator management
    let audit_event: AuditEvent = AuditEvent::new_global(actor, cause, action, before, after);

    // Persist audit event
    persistence
        .persist_audit_event(&audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    Ok(ChangePasswordResponse {
        message: String::from("Password changed successfully. All sessions have been invalidated."),
    })
}

/// Resets another operator's password (admin only).
///
/// Only Admin actors may reset other operators' passwords.
/// Does not require the old password, enforces password policy, and invalidates all sessions.
/// Emits an audit event on success.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The reset password request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data for audit attribution (the admin)
/// * `cause` - The cause for this action
///
/// # Returns
///
/// * `Ok(ResetPasswordResponse)` on success
/// * `Err(ApiError)` if unauthorized or operation fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The target operator does not exist
/// - New password does not meet policy requirements
/// - Password confirmation does not match
/// - Database operations fail
pub fn reset_password(
    persistence: &mut SqlitePersistence,
    request: &ResetPasswordRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<ResetPasswordResponse, ApiError> {
    // Enforce authorization before executing command
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("reset_password"),
            required_role: String::from("Admin"),
        });
    }

    // Get target operator to verify existence and get details for validation and audit
    let target_operator: OperatorData = persistence
        .get_operator_by_id(request.operator_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to get operator: {e}"),
        })?
        .ok_or_else(|| {
            let operator_id = request.operator_id;
            ApiError::ResourceNotFound {
                resource_type: String::from("Operator"),
                message: format!("Operator with ID {operator_id} not found"),
            }
        })?;

    // Validate new password policy
    let policy: PasswordPolicy = PasswordPolicy::default();
    policy.validate(
        &request.new_password,
        &request.new_password_confirmation,
        &target_operator.login_name,
        &target_operator.display_name,
    )?;

    // Update password
    persistence
        .update_password(request.operator_id, &request.new_password)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to update password: {e}"),
        })?;

    // Invalidate all sessions for the target operator
    persistence
        .delete_sessions_for_operator(request.operator_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to invalidate sessions: {e}"),
        })?;

    // Create audit event for password reset
    let actor: Actor = Actor::with_operator(
        operator.operator_id.to_string(),
        String::from("operator"),
        operator.operator_id,
        operator.login_name.clone(),
        operator.display_name.clone(),
    );

    let action: Action = Action::new(
        String::from("ResetPassword"),
        Some(format!(
            "Admin {} reset password for operator {}",
            operator.login_name, target_operator.login_name
        )),
    );

    let operator_id = request.operator_id;
    let target_login = &target_operator.login_name;
    let before: StateSnapshot = StateSnapshot::new(format!(
        "operator_id={operator_id},login_name={target_login}"
    ));
    let after: StateSnapshot = StateSnapshot::new(format!(
        "operator_id={operator_id},login_name={target_login},password_reset"
    ));

    // Phase 23B: Use global event for operator management
    let audit_event: AuditEvent = AuditEvent::new_global(actor, cause, action, before, after);

    // Persist audit event
    persistence
        .persist_audit_event(&audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    Ok(ResetPasswordResponse {
        message: format!(
            "Password reset successfully for operator {}. All sessions have been invalidated.",
            target_operator.login_name
        ),
        operator_id: request.operator_id,
    })
}

// ========================================================================
// Bootstrap Authentication (Phase 15)
// ========================================================================

/// Checks whether the system is in bootstrap mode.
///
/// Bootstrap mode is active when no operators exist in the database.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
///
/// # Returns
///
/// * `Ok(BootstrapAuthStatusResponse)` indicating bootstrap status
/// * `Err(ApiError)` if the query fails
///
/// # Errors
///
/// Returns an error if database operations fail.
pub fn check_bootstrap_status(
    persistence: &mut SqlitePersistence,
) -> Result<crate::BootstrapAuthStatusResponse, ApiError> {
    let operator_count: i64 = persistence
        .count_operators()
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to count operators: {e}"),
        })?;

    Ok(crate::BootstrapAuthStatusResponse {
        is_bootstrap_mode: operator_count == 0,
    })
}

/// Performs bootstrap login with hardcoded credentials.
///
/// This function only succeeds when:
/// - No operators exist in the database (bootstrap mode)
/// - Username is exactly "admin"
/// - Password is exactly "admin"
///
/// The returned token is a temporary bootstrap session, not a real operator session.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The bootstrap login request
///
/// # Returns
///
/// * `Ok(BootstrapLoginResponse)` with a bootstrap token
/// * `Err(ApiError)` if bootstrap mode is not active or credentials are invalid
///
/// # Errors
///
/// Returns an error if:
/// - Operators already exist (not in bootstrap mode)
/// - Credentials are not exactly "admin" / "admin"
/// - Database operations fail
///
/// # Panics
///
/// Panics if the system time is before the Unix epoch.
pub fn bootstrap_login(
    persistence: &mut SqlitePersistence,
    request: &crate::BootstrapLoginRequest,
) -> Result<crate::BootstrapLoginResponse, ApiError> {
    // Check if we're in bootstrap mode
    let operator_count: i64 = persistence
        .count_operators()
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to count operators: {e}"),
        })?;

    if operator_count > 0 {
        return Err(ApiError::Unauthorized {
            action: String::from("bootstrap_login"),
            required_role: String::from("Bootstrap mode (no operators exist)"),
        });
    }

    // Verify hardcoded credentials
    if request.username != "admin" || request.password != "admin" {
        return Err(ApiError::from(AuthError::AuthenticationFailed {
            reason: String::from("Invalid bootstrap credentials"),
        }));
    }

    // Generate a bootstrap token (simple, temporary)
    let timestamp: u128 = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_nanos();
    let bootstrap_token: String = format!("bootstrap_{timestamp}_{}", rand::random::<u64>());

    Ok(crate::BootstrapLoginResponse {
        bootstrap_token,
        is_bootstrap: true,
    })
}

/// Creates the first admin operator during bootstrap.
///
/// This function only succeeds when:
/// - No operators exist in the database (bootstrap mode)
/// - A valid bootstrap token is provided
///
/// After successful creation, the bootstrap session is terminated and
/// the system transitions out of bootstrap mode.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The create first admin request
///
/// # Returns
///
/// * `Ok(CreateFirstAdminResponse)` on success
/// * `Err(ApiError)` if not in bootstrap mode or creation fails
///
/// # Errors
///
/// Returns an error if:
/// - Operators already exist (not in bootstrap mode)
/// - Login name already exists
/// - Password validation fails
/// - Database operations fail
pub fn create_first_admin(
    persistence: &mut SqlitePersistence,
    request: crate::CreateFirstAdminRequest,
) -> Result<crate::CreateFirstAdminResponse, ApiError> {
    // Check if we're in bootstrap mode
    let operator_count: i64 = persistence
        .count_operators()
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to count operators: {e}"),
        })?;

    if operator_count > 0 {
        return Err(ApiError::Unauthorized {
            action: String::from("create_first_admin"),
            required_role: String::from("Bootstrap mode (no operators exist)"),
        });
    }

    // Validate password policy
    let policy: PasswordPolicy = PasswordPolicy::default();
    policy.validate(
        &request.password,
        &request.password_confirmation,
        &request.login_name,
        &request.display_name,
    )?;

    // Create the first admin operator
    let operator_id: i64 = persistence
        .create_operator(
            &request.login_name,
            &request.display_name,
            &request.password,
            "Admin",
        )
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to create first admin: {e}"),
        })?;

    Ok(crate::CreateFirstAdminResponse {
        operator_id,
        login_name: request.login_name,
        display_name: request.display_name,
        message: String::from("First admin operator created successfully"),
    })
}

// ========================================================================
// Phase 18: Bootstrap Workflow Completion Handlers
// ========================================================================

/// Sets the active bid year.
#[allow(dead_code)]
///
/// Only admins can set the active bid year.
/// Exactly one bid year may be active at a time.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `metadata` - The current bootstrap metadata
/// * `request` - The set active bid year request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data
/// * `cause` - The cause or reason for this action
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The bid year does not exist
/// - Database operations fail
pub fn set_active_bid_year(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
    request: &SetActiveBidYearRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<SetActiveBidYearResponse, ApiError> {
    // Enforce authorization - only admins can set active bid year
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("set_active_bid_year"),
            required_role: String::from("Admin"),
        });
    }

    // Resolve bid_year_id to BidYear from metadata
    let bid_year: &BidYear = metadata
        .bid_years
        .iter()
        .find(|by| by.bid_year_id() == Some(request.bid_year_id))
        .ok_or_else(|| ApiError::ResourceNotFound {
            resource_type: String::from("BidYear"),
            message: format!("Bid year with ID {} not found", request.bid_year_id),
        })?;

    let year: u16 = bid_year.year();

    // Apply the command
    let command = Command::SetActiveBidYear { year };
    let actor: Actor = authenticated_actor.to_audit_actor(operator);
    let result: BootstrapResult =
        apply_bootstrap(metadata, bid_year, command, actor, cause).map_err(translate_core_error)?;

    // Persist the active bid year setting
    persistence
        .set_active_bid_year(bid_year)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to set active bid year: {e}"),
        })?;

    // Persist audit event
    persistence
        .persist_audit_event(&result.audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    Ok(SetActiveBidYearResponse {
        bid_year_id: request.bid_year_id,
        year,
        message: format!("Bid year {year} is now active"),
    })
}

/// Transitions a bid year from `Draft` to `BootstrapComplete`.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `metadata` - The current bootstrap metadata
/// * `request` - The transition request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data
/// * `cause` - The cause or reason for this action
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The bid year does not exist
/// - Bootstrap is not complete
/// - The transition is invalid
pub fn transition_to_bootstrap_complete(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
    request: &TransitionToBootstrapCompleteRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<TransitionToBootstrapCompleteResponse, ApiError> {
    // Enforce authorization - only admins can transition lifecycle states
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("transition_to_bootstrap_complete"),
            required_role: String::from("Admin"),
        });
    }

    // Resolve bid_year_id to BidYear from metadata
    let bid_year: &BidYear = metadata
        .bid_years
        .iter()
        .find(|by| by.bid_year_id() == Some(request.bid_year_id))
        .ok_or_else(|| ApiError::ResourceNotFound {
            resource_type: String::from("BidYear"),
            message: format!("Bid year with ID {} not found", request.bid_year_id),
        })?;

    let year: u16 = bid_year.year();

    // Load current lifecycle state
    let current_state_str: String = persistence
        .get_lifecycle_state(request.bid_year_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to get lifecycle state: {e}"),
        })?;

    let current_state: zab_bid_domain::BidYearLifecycle =
        current_state_str.parse().map_err(translate_domain_error)?;

    let target_state = zab_bid_domain::BidYearLifecycle::BootstrapComplete;

    // Validate transition
    if !current_state.can_transition_to(target_state) {
        return Err(translate_domain_error(
            DomainError::InvalidStateTransition {
                current: current_state.as_str().to_string(),
                target: target_state.as_str().to_string(),
            },
        ));
    }

    // Check bootstrap completeness
    let completeness_response: GetBootstrapCompletenessResponse =
        get_bootstrap_completeness(persistence, metadata)?;
    if !completeness_response.is_ready_for_bidding {
        return Err(translate_domain_error(DomainError::BootstrapIncomplete));
    }

    // Phase 25B: Check for users in No Bid area
    let users_in_no_bid: usize = persistence
        .count_users_in_system_area(request.bid_year_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to check No Bid area: {e}"),
        })?;

    if users_in_no_bid > 0 {
        let sample_initials: Vec<String> = persistence
            .list_users_in_system_area(request.bid_year_id, 5)
            .map_err(|e| ApiError::Internal {
                message: format!("Failed to list users in No Bid area: {e}"),
            })?;

        return Err(translate_domain_error(DomainError::UsersInNoBidArea {
            bid_year: year,
            user_count: users_in_no_bid,
            sample_initials,
        }));
    }

    // Apply the command
    let command = Command::TransitionToBootstrapComplete { year };
    let actor: Actor = authenticated_actor.to_audit_actor(operator);
    let result: BootstrapResult =
        apply_bootstrap(metadata, bid_year, command, actor, cause).map_err(translate_core_error)?;

    // Persist the lifecycle state change
    persistence
        .update_lifecycle_state(request.bid_year_id, target_state.as_str())
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to update lifecycle state: {e}"),
        })?;

    // Persist audit event
    persistence
        .persist_audit_event(&result.audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    Ok(TransitionToBootstrapCompleteResponse {
        bid_year_id: request.bid_year_id,
        year,
        lifecycle_state: target_state.as_str().to_string(),
        message: format!("Bid year {year} transitioned to {}", target_state.as_str()),
    })
}

/// Transitions a bid year from `BootstrapComplete` to `Canonicalized`.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `metadata` - The current bootstrap metadata
/// * `request` - The transition request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data
/// * `cause` - The cause or reason for this action
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The bid year does not exist
/// - The transition is invalid
pub fn transition_to_canonicalized(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
    request: &TransitionToCanonicalizedRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<TransitionToCanonicalizedResponse, ApiError> {
    // Enforce authorization - only admins can transition lifecycle states
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("transition_to_canonicalized"),
            required_role: String::from("Admin"),
        });
    }

    // Resolve bid_year_id to BidYear from metadata
    let bid_year: &BidYear = metadata
        .bid_years
        .iter()
        .find(|by| by.bid_year_id() == Some(request.bid_year_id))
        .ok_or_else(|| ApiError::ResourceNotFound {
            resource_type: String::from("BidYear"),
            message: format!("Bid year with ID {} not found", request.bid_year_id),
        })?;

    let year: u16 = bid_year.year();

    // Load current lifecycle state
    let current_state_str: String = persistence
        .get_lifecycle_state(request.bid_year_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to get lifecycle state: {e}"),
        })?;

    let current_state: zab_bid_domain::BidYearLifecycle =
        current_state_str.parse().map_err(translate_domain_error)?;

    let target_state = zab_bid_domain::BidYearLifecycle::Canonicalized;

    // Validate transition
    if !current_state.can_transition_to(target_state) {
        return Err(translate_domain_error(
            DomainError::InvalidStateTransition {
                current: current_state.as_str().to_string(),
                target: target_state.as_str().to_string(),
            },
        ));
    }

    // Check for users in No Bid area (Phase 25B enforcement)
    let users_in_no_bid: usize = persistence
        .count_users_in_system_area(request.bid_year_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to check No Bid area: {e}"),
        })?;

    if users_in_no_bid > 0 {
        let sample_initials: Vec<String> = persistence
            .list_users_in_system_area(request.bid_year_id, 5)
            .map_err(|e| ApiError::Internal {
                message: format!("Failed to list users in No Bid area: {e}"),
            })?;

        return Err(translate_domain_error(DomainError::UsersInNoBidArea {
            bid_year: year,
            user_count: users_in_no_bid,
            sample_initials,
        }));
    }

    // Apply the command to get the audit event
    let command = Command::TransitionToCanonicalized { year };
    let actor: Actor = authenticated_actor.to_audit_actor(operator);
    let result: BootstrapResult =
        apply_bootstrap(metadata, bid_year, command, actor, cause).map_err(translate_core_error)?;

    // Perform canonicalization (within implicit transaction via persistence layer)
    persistence
        .canonicalize_bid_year(request.bid_year_id, &result.audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to canonicalize bid year: {e}"),
        })?;

    // Update lifecycle state
    persistence
        .update_lifecycle_state(request.bid_year_id, target_state.as_str())
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to update lifecycle state: {e}"),
        })?;

    Ok(TransitionToCanonicalizedResponse {
        bid_year_id: request.bid_year_id,
        year,
        lifecycle_state: target_state.as_str().to_string(),
        message: format!("Bid year {year} transitioned to {}", target_state.as_str()),
    })
}

/// Transitions a bid year from `Canonicalized` to `BiddingActive`.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `metadata` - The current bootstrap metadata
/// * `request` - The transition request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data
/// * `cause` - The cause or reason for this action
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The bid year does not exist
/// - Another bid year is already `BiddingActive`
/// - The transition is invalid
pub fn transition_to_bidding_active(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
    request: &TransitionToBiddingActiveRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<TransitionToBiddingActiveResponse, ApiError> {
    // Enforce authorization - only admins can transition lifecycle states
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("transition_to_bidding_active"),
            required_role: String::from("Admin"),
        });
    }

    // Resolve bid_year_id to BidYear from metadata
    let bid_year: &BidYear = metadata
        .bid_years
        .iter()
        .find(|by| by.bid_year_id() == Some(request.bid_year_id))
        .ok_or_else(|| ApiError::ResourceNotFound {
            resource_type: String::from("BidYear"),
            message: format!("Bid year with ID {} not found", request.bid_year_id),
        })?;

    let year: u16 = bid_year.year();

    // Load current lifecycle state
    let current_state_str: String = persistence
        .get_lifecycle_state(request.bid_year_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to get lifecycle state: {e}"),
        })?;

    let current_state: zab_bid_domain::BidYearLifecycle =
        current_state_str.parse().map_err(translate_domain_error)?;

    let target_state = zab_bid_domain::BidYearLifecycle::BiddingActive;

    // Validate transition
    if !current_state.can_transition_to(target_state) {
        return Err(translate_domain_error(
            DomainError::InvalidStateTransition {
                current: current_state.as_str().to_string(),
                target: target_state.as_str().to_string(),
            },
        ));
    }

    // Check if another bid year is already BiddingActive
    if let Some(active_year) =
        persistence
            .get_bidding_active_year()
            .map_err(|e| ApiError::Internal {
                message: format!("Failed to check for active bid year: {e}"),
            })?
        && active_year != year
    {
        return Err(translate_domain_error(
            DomainError::AnotherBidYearAlreadyActive { active_year },
        ));
    }

    // Apply the command
    let command = Command::TransitionToBiddingActive { year };
    let actor: Actor = authenticated_actor.to_audit_actor(operator);
    let result: BootstrapResult =
        apply_bootstrap(metadata, bid_year, command, actor, cause).map_err(translate_core_error)?;

    // Persist the lifecycle state change
    persistence
        .update_lifecycle_state(request.bid_year_id, target_state.as_str())
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to update lifecycle state: {e}"),
        })?;

    // Persist audit event
    persistence
        .persist_audit_event(&result.audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    Ok(TransitionToBiddingActiveResponse {
        bid_year_id: request.bid_year_id,
        year,
        lifecycle_state: target_state.as_str().to_string(),
        message: format!("Bid year {year} transitioned to {}", target_state.as_str()),
    })
}

/// Transitions a bid year from `BiddingActive` to `BiddingClosed`.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `metadata` - The current bootstrap metadata
/// * `request` - The transition request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data
/// * `cause` - The cause or reason for this action
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The bid year does not exist
/// - The transition is invalid
pub fn transition_to_bidding_closed(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
    request: &TransitionToBiddingClosedRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<TransitionToBiddingClosedResponse, ApiError> {
    // Enforce authorization - only admins can transition lifecycle states
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("transition_to_bidding_closed"),
            required_role: String::from("Admin"),
        });
    }

    // Resolve bid_year_id to BidYear from metadata
    let bid_year: &BidYear = metadata
        .bid_years
        .iter()
        .find(|by| by.bid_year_id() == Some(request.bid_year_id))
        .ok_or_else(|| ApiError::ResourceNotFound {
            resource_type: String::from("BidYear"),
            message: format!("Bid year with ID {} not found", request.bid_year_id),
        })?;

    let year: u16 = bid_year.year();

    // Load current lifecycle state
    let current_state_str: String = persistence
        .get_lifecycle_state(request.bid_year_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to get lifecycle state: {e}"),
        })?;

    let current_state: zab_bid_domain::BidYearLifecycle =
        current_state_str.parse().map_err(translate_domain_error)?;

    let target_state = zab_bid_domain::BidYearLifecycle::BiddingClosed;

    // Validate transition
    if !current_state.can_transition_to(target_state) {
        return Err(translate_domain_error(
            DomainError::InvalidStateTransition {
                current: current_state.as_str().to_string(),
                target: target_state.as_str().to_string(),
            },
        ));
    }

    // Apply the command
    let command = Command::TransitionToBiddingClosed { year };
    let actor: Actor = authenticated_actor.to_audit_actor(operator);
    let result: BootstrapResult =
        apply_bootstrap(metadata, bid_year, command, actor, cause).map_err(translate_core_error)?;

    // Persist the lifecycle state change
    persistence
        .update_lifecycle_state(request.bid_year_id, target_state.as_str())
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to update lifecycle state: {e}"),
        })?;

    // Persist audit event
    persistence
        .persist_audit_event(&result.audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    Ok(TransitionToBiddingClosedResponse {
        bid_year_id: request.bid_year_id,
        year,
        lifecycle_state: target_state.as_str().to_string(),
        message: format!("Bid year {year} transitioned to {}", target_state.as_str()),
    })
}

/// Gets the currently active bid year.
#[allow(dead_code)]
///
/// # Arguments
///
/// * `persistence` - The persistence layer
///
/// # Errors
///
/// Returns an error if database operations fail.
pub fn get_active_bid_year(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
) -> Result<GetActiveBidYearResponse, ApiError> {
    let year: u16 = persistence
        .get_active_bid_year()
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to get active bid year: {e}"),
        })?;

    // Extract bid_year_id if there is an active year
    let bid_year_id: Option<i64> = metadata
        .bid_years
        .iter()
        .find(|by| by.year() == year)
        .and_then(zab_bid_domain::BidYear::bid_year_id);

    Ok(GetActiveBidYearResponse {
        bid_year_id,
        year: Some(year),
    })
}

/// Sets the expected area count for a bid year.
#[allow(dead_code)]
///
/// Only admins can set expected area counts.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `metadata` - The current bootstrap metadata
/// * `request` - The set expected area count request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data
/// * `cause` - The cause or reason for this action
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The bid year does not exist
/// - The expected count is zero
/// - Database operations fail
pub fn set_expected_area_count(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
    request: &SetExpectedAreaCountRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<SetExpectedAreaCountResponse, ApiError> {
    // Enforce authorization - only admins can set expected counts
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("set_expected_area_count"),
            required_role: String::from("Admin"),
        });
    }

    // Resolve the active bid year from canonical state
    let active_bid_year: BidYear = resolve_active_bid_year(persistence)?;

    let command = Command::SetExpectedAreaCount {
        expected_count: request.expected_count,
    };

    let actor: Actor = authenticated_actor.to_audit_actor(operator);
    let result: BootstrapResult =
        apply_bootstrap(metadata, &active_bid_year, command, actor, cause)
            .map_err(translate_core_error)?;

    // Persist the expected area count
    persistence
        .set_expected_area_count(&active_bid_year, request.expected_count as usize)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to set expected area count: {e}"),
        })?;

    // Persist audit event
    persistence
        .persist_audit_event(&result.audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    // Extract bid_year_id from metadata
    let bid_year_id: i64 = metadata
        .bid_years
        .iter()
        .find(|by| by.year() == active_bid_year.year())
        .and_then(zab_bid_domain::BidYear::bid_year_id)
        .ok_or_else(|| ApiError::Internal {
            message: format!(
                "Bid year {} exists but has no ID in metadata",
                active_bid_year.year()
            ),
        })?;

    Ok(SetExpectedAreaCountResponse {
        bid_year_id,
        bid_year: active_bid_year.year(),
        expected_count: request.expected_count,
        message: format!(
            "Expected area count set to {} for bid year {}",
            request.expected_count,
            active_bid_year.year()
        ),
    })
}

/// Sets the expected user count for an area.
#[allow(dead_code)]
///
/// Only admins can set expected user counts.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `metadata` - The current bootstrap metadata
/// * `request` - The set expected user count request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data
/// * `cause` - The cause or reason for this action
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The bid year or area does not exist
/// - The expected count is zero
/// - Database operations fail
pub fn set_expected_user_count(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
    request: &SetExpectedUserCountRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<SetExpectedUserCountResponse, ApiError> {
    // Enforce authorization - only admins can set expected counts
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("set_expected_user_count"),
            required_role: String::from("Admin"),
        });
    }

    // Resolve the active bid year from canonical state
    let active_bid_year: BidYear = resolve_active_bid_year(persistence)?;

    // Resolve area_id to Area from metadata
    let area: &Area = metadata
        .areas
        .iter()
        .filter(|(by, _)| by.year() == active_bid_year.year())
        .find(|(_, a)| a.area_id() == Some(request.area_id))
        .map(|(_, a)| a)
        .ok_or_else(|| ApiError::ResourceNotFound {
            resource_type: String::from("Area"),
            message: format!(
                "Area with ID {} not found in active bid year",
                request.area_id
            ),
        })?;

    let command = Command::SetExpectedUserCount {
        area: area.clone(),
        expected_count: request.expected_count,
    };

    let actor: Actor = authenticated_actor.to_audit_actor(operator);
    let result: BootstrapResult =
        apply_bootstrap(metadata, &active_bid_year, command, actor, cause)
            .map_err(translate_core_error)?;

    // Persist the expected user count
    persistence
        .set_expected_user_count(&active_bid_year, area, request.expected_count as usize)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to set expected user count: {e}"),
        })?;

    // Persist audit event
    persistence
        .persist_audit_event(&result.audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    // Extract bid_year_id from metadata
    let bid_year_id: i64 = metadata
        .bid_years
        .iter()
        .find(|by| by.year() == active_bid_year.year())
        .and_then(zab_bid_domain::BidYear::bid_year_id)
        .ok_or_else(|| ApiError::Internal {
            message: format!(
                "Bid year {} exists but has no ID in metadata",
                active_bid_year.year()
            ),
        })?;

    Ok(SetExpectedUserCountResponse {
        bid_year_id,
        bid_year: active_bid_year.year(),
        area_id: request.area_id,
        area_code: area.area_code().to_string(),
        expected_count: request.expected_count,
        message: format!(
            "Expected user count set to {} for area '{}' in bid year {}",
            request.expected_count,
            area.area_code(),
            active_bid_year.year()
        ),
    })
}

/// Updates an existing user's information.
#[allow(dead_code)]
///
/// Only admins can update users.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `metadata` - The current bootstrap metadata
/// * `state` - The current system state
/// * `request` - The update user request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data
/// * `cause` - The cause or reason for this action
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The user does not exist
/// - Validation fails
/// - Database operations fail
pub fn update_user(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
    state: &State,
    request: &UpdateUserRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<ApiResult<UpdateUserResponse>, ApiError> {
    // Enforce authorization - only admins can update users
    AuthorizationService::authorize_register_user(authenticated_actor)?;

    // Resolve the active bid year from canonical state
    let active_bid_year: BidYear = resolve_active_bid_year(persistence)?;

    // Resolve area_id to Area from metadata
    let area: &Area = metadata
        .areas
        .iter()
        .filter(|(by, _)| by.year() == active_bid_year.year())
        .find(|(_, a)| a.area_id() == Some(request.area_id))
        .map(|(_, a)| a)
        .ok_or_else(|| ApiError::ResourceNotFound {
            resource_type: String::from("Area"),
            message: format!(
                "Area with ID {} not found in active bid year",
                request.area_id
            ),
        })?;

    // Translate API request into domain types
    let initials: Initials = Initials::new(&request.initials);
    let user_type: UserType =
        UserType::parse(&request.user_type).map_err(translate_domain_error)?;
    let crew: Option<Crew> = match request.crew {
        Some(crew_num) => Some(Crew::new(crew_num).map_err(translate_domain_error)?),
        None => None,
    };
    let seniority_data: SeniorityData = SeniorityData::new(
        request.cumulative_natca_bu_date.clone(),
        request.natca_bu_date.clone(),
        request.eod_faa_date.clone(),
        request.service_computation_date.clone(),
        request.lottery_value,
    );

    // Create command
    let command = Command::UpdateUser {
        initials: initials.clone(),
        name: request.name.clone(),
        area: area.clone(),
        user_type,
        crew,
        seniority_data,
    };

    // Convert authenticated actor to audit actor
    let actor: Actor = authenticated_actor.to_audit_actor(operator);

    // Apply the command
    let result: TransitionResult = apply(metadata, state, &active_bid_year, command, actor, cause)
        .map_err(translate_core_error)?;

    // Persist the updated canonical user state using user_id from request
    persistence
        .update_user(
            request.user_id,
            &initials,
            &request.name,
            area,
            &request.user_type,
            request.crew,
            &request.cumulative_natca_bu_date,
            &request.natca_bu_date,
            &request.eod_faa_date,
            &request.service_computation_date,
            request.lottery_value,
        )
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to update user: {e}"),
        })?;

    // Persist audit event
    persistence
        .persist_audit_event(&result.audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    // Extract bid_year_id from metadata
    let bid_year_id: i64 = metadata
        .bid_years
        .iter()
        .find(|by| by.year() == active_bid_year.year())
        .and_then(zab_bid_domain::BidYear::bid_year_id)
        .ok_or_else(|| ApiError::Internal {
            message: format!(
                "Bid year {} exists but has no ID in metadata",
                active_bid_year.year()
            ),
        })?;

    // Build response
    let response = UpdateUserResponse {
        bid_year_id,
        bid_year: active_bid_year.year(),
        user_id: request.user_id,
        initials: request.initials.clone(),
        name: request.name.clone(),
        message: String::from("User updated successfully"),
    };

    Ok(ApiResult {
        response,
        audit_event: result.audit_event,
        new_state: result.new_state,
    })
}

/// Gets the bootstrap completeness status for all bid years and areas.
#[allow(dead_code)]
///
/// This function computes whether each bid year and area meets its
/// expected counts and returns detailed blocking reasons.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `metadata` - The current bootstrap metadata
///
/// # Errors
///
/// Returns an error if database operations fail.
#[allow(clippy::too_many_lines)]
pub fn get_bootstrap_completeness(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
) -> Result<GetBootstrapCompletenessResponse, ApiError> {
    let active_bid_year: Option<u16> = persistence.get_active_bid_year().ok();

    // Extract active_bid_year_id if there is an active year
    let active_bid_year_id: Option<i64> = active_bid_year.and_then(|y| {
        metadata
            .bid_years
            .iter()
            .find(|by| by.year() == y)
            .and_then(zab_bid_domain::BidYear::bid_year_id)
    });

    let mut bid_years_info: Vec<BidYearCompletenessInfo> = Vec::new();
    let mut areas_info: Vec<AreaCompletenessInfo> = Vec::new();
    let mut top_level_blocking: Vec<BlockingReason> = Vec::new();

    // If no active bid year, that's a top-level blocker
    if active_bid_year.is_none() {
        top_level_blocking.push(BlockingReason::NoActiveBidYear);
    }

    // Check each bid year
    for bid_year in &metadata.bid_years {
        let year: u16 = bid_year.year();
        let bid_year_id: i64 = bid_year.bid_year_id().ok_or_else(|| ApiError::Internal {
            message: format!("Bid year {year} has no ID in metadata"),
        })?;
        let is_active: bool = active_bid_year == Some(year);

        let expected_area_count: Option<u32> = persistence
            .get_expected_area_count(&BidYear::new(year))
            .map_err(|e| ApiError::Internal {
                message: format!("Failed to get expected area count: {e}"),
            })?
            .map(|v| {
                u32::try_from(v).unwrap_or_else(|_| {
                    tracing::warn!("Expected area count out of range: {}", v);
                    u32::MAX
                })
            });

        let actual_area_count: usize = persistence
            .get_actual_area_count(&BidYear::new(year))
            .map_err(|e| ApiError::Internal {
                message: format!("Failed to get actual area count: {e}"),
            })?;

        let mut blocking_reasons: Vec<BlockingReason> = Vec::new();

        // Check if expected count is set
        let expected_count = expected_area_count.unwrap_or_else(|| {
            blocking_reasons.push(BlockingReason::ExpectedAreaCountNotSet {
                bid_year_id,
                bid_year: year,
            });
            0 // Placeholder
        });

        // Check if actual matches expected
        if expected_area_count.is_some() && actual_area_count != expected_count as usize {
            blocking_reasons.push(BlockingReason::AreaCountMismatch {
                bid_year_id,
                bid_year: year,
                expected: expected_count,
                actual: actual_area_count,
            });
        }

        let is_complete: bool = blocking_reasons.is_empty() && expected_area_count.is_some();

        bid_years_info.push(BidYearCompletenessInfo {
            bid_year_id,
            year,
            is_active,
            expected_area_count,
            actual_area_count,
            is_complete,
            blocking_reasons,
        });
    }

    // Check each area
    for (bid_year, area) in &metadata.areas {
        let year: u16 = bid_year.year();
        let bid_year_id: i64 = metadata
            .bid_years
            .iter()
            .find(|by| by.year() == year)
            .and_then(zab_bid_domain::BidYear::bid_year_id)
            .ok_or_else(|| ApiError::Internal {
                message: format!("Bid year {year} has no ID in metadata"),
            })?;
        let area_code: String = area.area_code().to_string();
        let area_id: i64 = area.area_id().ok_or_else(|| ApiError::Internal {
            message: format!("Area '{area_code}' in bid year {year} has no ID in metadata"),
        })?;

        let expected_user_count: Option<u32> = persistence
            .get_expected_user_count(bid_year, area)
            .map_err(|e| ApiError::Internal {
                message: format!("Failed to get expected user count: {e}"),
            })?
            .map(|v| {
                u32::try_from(v).unwrap_or_else(|_| {
                    tracing::warn!("Expected user count out of range: {}", v);
                    u32::MAX
                })
            });

        let actual_user_count: usize =
            persistence
                .get_actual_user_count(bid_year, area)
                .map_err(|e| ApiError::Internal {
                    message: format!("Failed to get actual user count: {e}"),
                })?;

        let mut blocking_reasons: Vec<BlockingReason> = Vec::new();

        // Check if expected count is set
        let expected_count = expected_user_count.unwrap_or_else(|| {
            blocking_reasons.push(BlockingReason::ExpectedUserCountNotSet {
                bid_year_id,
                bid_year: year,
                area_id,
                area_code: area_code.clone(),
            });
            0 // Placeholder
        });

        // Check if actual matches expected
        if expected_user_count.is_some() && actual_user_count != expected_count as usize {
            blocking_reasons.push(BlockingReason::UserCountMismatch {
                bid_year_id,
                bid_year: year,
                area_id,
                area_code: area_code.clone(),
                expected: expected_count,
                actual: actual_user_count,
            });
        }

        let is_complete: bool = blocking_reasons.is_empty() && expected_user_count.is_some();

        areas_info.push(AreaCompletenessInfo {
            bid_year_id,
            bid_year: year,
            area_id,
            area_code,
            expected_user_count,
            actual_user_count,
            is_complete,
            blocking_reasons,
        });
    }

    // Determine if system is ready for bidding
    let is_ready_for_bidding: bool = active_bid_year.is_some()
        && bid_years_info.iter().all(|b| b.is_complete)
        && areas_info.iter().all(|a| a.is_complete);

    Ok(GetBootstrapCompletenessResponse {
        active_bid_year_id,
        active_bid_year,
        bid_years: bid_years_info,
        areas: areas_info,
        is_ready_for_bidding,
        blocking_reasons: top_level_blocking,
    })
}

/// Previews and validates CSV user data without persisting.
///
/// This handler:
/// - Accepts CSV content and a bid year
/// - Parses and validates each row
/// - Returns structured preview results
/// - Does NOT mutate state or emit audit events
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `persistence` - The persistence layer for querying existing users
/// * `request` - The preview request containing bid year and CSV content
/// * `authenticated_actor` - The authenticated actor making the request
///
/// # Returns
///
/// * `Ok(PreviewCsvUsersResponse)` with per-row validation results
/// * `Err(ApiError)` if unauthorized or CSV format is invalid
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not an admin
/// - The bid year does not exist
/// - The CSV format is invalid
pub fn preview_csv_users(
    metadata: &BootstrapMetadata,
    persistence: &mut SqlitePersistence,
    request: &PreviewCsvUsersRequest,
    authenticated_actor: &AuthenticatedActor,
) -> Result<PreviewCsvUsersResponse, ApiError> {
    // Enforce authorization - only admins can preview CSV imports
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("preview_csv_users"),
            required_role: String::from("Admin"),
        });
    }

    // Resolve the active bid year from canonical state
    let active_bid_year: BidYear = resolve_active_bid_year(persistence)?;

    // Validate bid year exists
    validate_bid_year_exists(metadata, &active_bid_year).map_err(translate_domain_error)?;

    // Perform CSV preview validation
    let preview_result = preview_csv_users_impl(
        &request.csv_content,
        &active_bid_year,
        metadata,
        persistence,
    )?;

    // Convert internal result to API response
    let rows: Vec<CsvRowPreview> = preview_result
        .rows
        .into_iter()
        .map(|r: CsvRowResult| CsvRowPreview {
            row_number: r.row_number,
            initials: r.initials,
            name: r.name,
            area_id: r.area_id,
            user_type: r.user_type,
            crew: r.crew,
            status: match r.status {
                crate::csv_preview::CsvRowStatus::Valid => CsvRowStatus::Valid,
                crate::csv_preview::CsvRowStatus::Invalid => CsvRowStatus::Invalid,
            },
            errors: r.errors,
        })
        .collect();

    Ok(PreviewCsvUsersResponse {
        bid_year: active_bid_year.year(),
        rows,
        total_rows: preview_result.total_rows,
        valid_count: preview_result.valid_count,
        invalid_count: preview_result.invalid_count,
    })
}

/// Imports selected CSV rows as users.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Re-parses each selected CSV row
/// - Attempts to create each user individually
/// - Returns per-row success/failure results
/// - Does NOT roll back on failure
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `state` - The current system state
/// * `persistence` - The persistence layer
/// * `request` - The API request containing CSV content and selected row indices
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data for audit trail
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok((ImportCsvUsersResponse, Vec<AuditEvent>, State))` on completion
/// * `Err(ApiError)` if unauthorized or CSV parsing fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The CSV cannot be parsed
/// - The bid year does not exist
///
/// Individual row failures are captured in the response, not as errors.
#[allow(clippy::too_many_lines)]
pub fn import_csv_users(
    metadata: &BootstrapMetadata,
    _state: &State,
    persistence: &mut SqlitePersistence,
    request: &ImportCsvUsersRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: &Cause,
) -> Result<ImportCsvUsersResponse, ApiError> {
    // Enforce authorization - only admins can import users
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("import_csv_users"),
            required_role: String::from("Admin"),
        });
    }

    // Resolve the active bid year from canonical state
    let active_bid_year: BidYear = resolve_active_bid_year(persistence)?;

    // Validate bid year exists
    validate_bid_year_exists(metadata, &active_bid_year).map_err(translate_domain_error)?;

    // Convert authenticated actor to audit actor
    let actor: Actor = authenticated_actor.to_audit_actor(operator);

    // Parse CSV and collect all rows first
    let mut reader = csv::ReaderBuilder::new()
        .has_headers(true)
        .flexible(false)
        .from_reader(request.csv_content.as_bytes());

    let headers = reader
        .headers()
        .map_err(|e| ApiError::InvalidCsvFormat {
            reason: format!("Failed to read CSV headers: {e}"),
        })?
        .clone();

    // Build header map for field extraction
    let mut header_map: std::collections::HashMap<String, usize> = std::collections::HashMap::new();
    for (idx, header) in headers.iter().enumerate() {
        let normalized = header.trim().to_lowercase().replace(' ', "_");
        header_map.insert(normalized, idx);
    }

    // Collect all records into a vec so we can index into them
    let all_records: Vec<csv::StringRecord> = reader
        .records()
        .collect::<Result<Vec<_>, _>>()
        .map_err(|e| ApiError::InvalidCsvFormat {
            reason: format!("Failed to read CSV records: {e}"),
        })?;

    let total_selected: usize = request.selected_row_indices.len();
    let mut successful_count: usize = 0;
    let mut failed_count: usize = 0;
    let mut results: Vec<CsvImportRowResult> = Vec::new();

    // Process each selected row
    for &row_index in &request.selected_row_indices {
        let row_number: usize = row_index + 1;

        // Check if row index is valid
        if row_index >= all_records.len() {
            results.push(CsvImportRowResult {
                row_index,
                row_number,
                initials: None,
                status: CsvImportRowStatus::Failed,
                error: Some(String::from("Row index out of bounds")),
            });
            failed_count += 1;
            continue;
        }

        let record = &all_records[row_index];

        // Extract fields using header map
        let get_field = |name: &str| -> Option<String> {
            header_map
                .get(name)
                .and_then(|&idx| record.get(idx))
                .map(|s| s.trim().to_string())
                .filter(|s| !s.is_empty())
        };

        // Extract required fields
        let Some(initials_str) = get_field("initials") else {
            results.push(CsvImportRowResult {
                row_index,
                row_number,
                initials: None,
                status: CsvImportRowStatus::Failed,
                error: Some(String::from("Missing initials")),
            });
            failed_count += 1;
            continue;
        };

        let Some(name) = get_field("name") else {
            results.push(CsvImportRowResult {
                row_index,
                row_number,
                initials: Some(initials_str.clone()),
                status: CsvImportRowStatus::Failed,
                error: Some(String::from("Missing name")),
            });
            failed_count += 1;
            continue;
        };

        let Some(area_str) = get_field("area_id") else {
            results.push(CsvImportRowResult {
                row_index,
                row_number,
                initials: Some(initials_str.clone()),
                status: CsvImportRowStatus::Failed,
                error: Some(String::from("Missing area_id")),
            });
            failed_count += 1;
            continue;
        };

        let Some(user_type_str) = get_field("user_type") else {
            results.push(CsvImportRowResult {
                row_index,
                row_number,
                initials: Some(initials_str.clone()),
                status: CsvImportRowStatus::Failed,
                error: Some(String::from("Missing user_type")),
            });
            failed_count += 1;
            continue;
        };

        let Some(crew_str) = get_field("crew") else {
            results.push(CsvImportRowResult {
                row_index,
                row_number,
                initials: Some(initials_str.clone()),
                status: CsvImportRowStatus::Failed,
                error: Some(String::from("Missing crew")),
            });
            failed_count += 1;
            continue;
        };

        let Some(service_computation_date) = get_field("service_computation_date") else {
            results.push(CsvImportRowResult {
                row_index,
                row_number,
                initials: Some(initials_str.clone()),
                status: CsvImportRowStatus::Failed,
                error: Some(String::from("Missing service_computation_date")),
            });
            failed_count += 1;
            continue;
        };

        let Some(eod_faa_date) = get_field("eod_faa_date").or_else(|| get_field("eod_date")) else {
            results.push(CsvImportRowResult {
                row_index,
                row_number,
                initials: Some(initials_str.clone()),
                status: CsvImportRowStatus::Failed,
                error: Some(String::from("Missing eod_faa_date or eod_date")),
            });
            failed_count += 1;
            continue;
        };

        // Parse crew
        let Ok(crew_num) = crew_str.parse::<u8>() else {
            results.push(CsvImportRowResult {
                row_index,
                row_number,
                initials: Some(initials_str.clone()),
                status: CsvImportRowStatus::Failed,
                error: Some(format!("Invalid crew number: {crew_str}")),
            });
            failed_count += 1;
            continue;
        };

        // Optional fields
        let cumulative_natca_bu_date = get_field("cumulative_natca_bu_date").unwrap_or_default();
        let natca_bu_date = get_field("natca_bu_date").unwrap_or_default();
        let lottery_value = get_field("lottery_value").and_then(|v| v.parse().ok());

        // Parse domain types
        let initials = Initials::new(&initials_str);
        let area = Area::new(&area_str);

        let user_type = match UserType::parse(&user_type_str).map_err(translate_domain_error) {
            Ok(ut) => ut,
            Err(e) => {
                results.push(CsvImportRowResult {
                    row_index,
                    row_number,
                    initials: Some(initials_str.clone()),
                    status: CsvImportRowStatus::Failed,
                    error: Some(format!("Invalid user type: {e}")),
                });
                failed_count += 1;
                continue;
            }
        };

        let crew = match Crew::new(crew_num).map_err(translate_domain_error) {
            Ok(c) => Some(c),
            Err(e) => {
                results.push(CsvImportRowResult {
                    row_index,
                    row_number,
                    initials: Some(initials_str.clone()),
                    status: CsvImportRowStatus::Failed,
                    error: Some(format!("Invalid crew: {e}")),
                });
                failed_count += 1;
                continue;
            }
        };

        let seniority_data = SeniorityData::new(
            cumulative_natca_bu_date,
            natca_bu_date,
            eod_faa_date,
            service_computation_date,
            lottery_value,
        );

        // Load current state for this user's area from the database
        // This ensures duplicate detection works correctly across areas
        let area_state: State = persistence
            .get_current_state(&active_bid_year, &area)
            .unwrap_or_else(|_| State::new(active_bid_year.clone(), area.clone()));

        // Create the command
        let command = Command::RegisterUser {
            initials: initials.clone(),
            name: name.clone(),
            area: area.clone(),
            user_type,
            crew,
            seniority_data,
        };

        // Attempt to apply the command
        match apply(
            metadata,
            &area_state,
            &active_bid_year,
            command,
            actor.clone(),
            cause.clone(),
        )
        .map_err(translate_core_error)
        {
            Ok(transition_result) => {
                // Persist immediately to ensure subsequent rows see this user
                if let Err(persist_err) = persistence.persist_transition(&transition_result) {
                    results.push(CsvImportRowResult {
                        row_index,
                        row_number,
                        initials: Some(initials.value().to_string()),
                        status: CsvImportRowStatus::Failed,
                        error: Some(format!("Failed to persist: {persist_err}")),
                    });
                    failed_count += 1;
                    continue;
                }

                // Success
                results.push(CsvImportRowResult {
                    row_index,
                    row_number,
                    initials: Some(initials.value().to_string()),
                    status: CsvImportRowStatus::Success,
                    error: None,
                });
                successful_count += 1;
            }
            Err(e) => {
                // Failure
                results.push(CsvImportRowResult {
                    row_index,
                    row_number,
                    initials: Some(initials.value().to_string()),
                    status: CsvImportRowStatus::Failed,
                    error: Some(format!("{e}")),
                });
                failed_count += 1;
            }
        }
    }

    let response = ImportCsvUsersResponse {
        bid_year: active_bid_year.year(),
        total_selected,
        successful_count,
        failed_count,
        results,
    };

    Ok(response)
}

/// Override a user's area assignment after canonicalization.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The override request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data
///
/// # Returns
///
/// Returns the audit event ID on success.
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not an admin
/// - The lifecycle state is not >= Canonicalized
/// - The override reason is invalid
/// - The target area is a system area
/// - The canonical record does not exist
#[allow(clippy::too_many_lines)]
#[allow(dead_code)]
pub fn override_area_assignment(
    persistence: &mut SqlitePersistence,
    request: &OverrideAreaAssignmentRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
) -> Result<OverrideAreaAssignmentResponse, ApiError> {
    // Enforce authorization - only admins can perform overrides
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("override_area_assignment"),
            required_role: String::from("Admin"),
        });
    }

    // Validate override reason (min 10 chars)
    let reason = request.reason.trim();
    if reason.len() < 10 {
        return Err(translate_domain_error(DomainError::InvalidOverrideReason {
            reason: request.reason.clone(),
        }));
    }

    // Get user details
    let (bid_year_id, user_initials): (i64, String) = persistence
        .get_user_details(request.user_id)
        .map_err(|_| ApiError::ResourceNotFound {
            resource_type: String::from("User"),
            message: format!("User with ID {} not found", request.user_id),
        })?;

    // Check lifecycle state >= Canonicalized
    let lifecycle_state =
        persistence
            .get_lifecycle_state(bid_year_id)
            .map_err(|e| ApiError::Internal {
                message: format!("Failed to get lifecycle state: {e}"),
            })?;

    if !matches!(
        lifecycle_state.as_str(),
        "Canonicalized" | "BiddingActive" | "BiddingClosed"
    ) {
        return Err(translate_domain_error(
            DomainError::CannotOverrideBeforeCanonicalization {
                current_state: lifecycle_state,
            },
        ));
    }

    // Verify target area exists and is not a system area
    let (area_code, area_name): (String, Option<String>) = persistence
        .get_area_details(request.new_area_id)
        .map_err(|_| ApiError::ResourceNotFound {
            resource_type: String::from("Area"),
            message: format!("Area with ID {} not found", request.new_area_id),
        })?;

    // Check if target area is a system area
    let is_system = persistence
        .is_system_area(request.new_area_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to check system area: {e}"),
        })?;

    if is_system {
        return Err(translate_domain_error(
            DomainError::CannotAssignToSystemArea { area_code },
        ));
    }

    // Get previous area info for audit event
    let previous_area_id: i64 = persistence
        .get_current_area_assignment(bid_year_id, request.user_id)
        .map_err(|_| {
            translate_domain_error(DomainError::CanonicalRecordNotFound {
                description: format!(
                    "Canonical area membership not found for user_id={}",
                    request.user_id
                ),
            })
        })?;

    let (prev_area_code, prev_area_name): (String, Option<String>) = persistence
        .get_area_details(previous_area_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to fetch previous area info: {e}"),
        })?;

    // Perform override
    let (_, was_already_overridden) = persistence
        .override_area_assignment(bid_year_id, request.user_id, request.new_area_id, reason)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to override area assignment: {e}"),
        })?;

    // Create and persist audit event
    let actor = authenticated_actor.to_audit_actor(operator);
    let cause = Cause::new(
        String::from("override_area_assignment"),
        format!("Override area assignment for user {user_initials}"),
    );

    let action = Action::new(
        String::from("UserAreaAssignmentOverridden"),
        Some(format!(
            "user_id={}, previous_area={}, new_area={}, reason={}, was_overridden={}",
            request.user_id,
            prev_area_name.unwrap_or(prev_area_code),
            area_name.unwrap_or(area_code),
            reason,
            was_already_overridden
        )),
    );

    let before = StateSnapshot::new(format!("area_id={previous_area_id}"));
    let after = StateSnapshot::new(format!("area_id={}", request.new_area_id));

    let year = persistence
        .get_bid_year_from_id(bid_year_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to get bid year: {e}"),
        })?;
    let bid_year = BidYear::new(year);
    let area = Area::new("_override");

    let audit_event = AuditEvent::new(actor, cause, action, before, after, bid_year, area);

    let event_id =
        persistence
            .persist_audit_event(&audit_event)
            .map_err(|e| ApiError::Internal {
                message: format!("Failed to persist audit event: {e}"),
            })?;

    Ok(OverrideAreaAssignmentResponse {
        audit_event_id: event_id,
        message: format!(
            "Area assignment overridden for user {user_initials} (audit event {event_id})"
        ),
    })
}

/// Override a user's eligibility after canonicalization.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The override request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data
///
/// # Returns
///
/// Returns the audit event ID on success.
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not an admin
/// - The lifecycle state is not >= Canonicalized
/// - The override reason is invalid
/// - The canonical record does not exist
#[allow(dead_code)]
pub fn override_eligibility(
    persistence: &mut SqlitePersistence,
    request: &OverrideEligibilityRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
) -> Result<OverrideEligibilityResponse, ApiError> {
    // Enforce authorization - only admins can perform overrides
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("override_eligibility"),
            required_role: String::from("Admin"),
        });
    }

    // Validate override reason (min 10 chars)
    let reason = request.reason.trim();
    if reason.len() < 10 {
        return Err(translate_domain_error(DomainError::InvalidOverrideReason {
            reason: request.reason.clone(),
        }));
    }

    // Get user details
    let (bid_year_id, user_initials): (i64, String) =
        persistence.get_user_details(request.user_id).map_err(|_| {
            let user_id = request.user_id;
            ApiError::ResourceNotFound {
                resource_type: String::from("User"),
                message: format!("User with ID {user_id} not found"),
            }
        })?;

    // Check lifecycle state >= Canonicalized
    let lifecycle_state =
        persistence
            .get_lifecycle_state(bid_year_id)
            .map_err(|e| ApiError::Internal {
                message: format!("Failed to get lifecycle state: {e}"),
            })?;

    if !matches!(
        lifecycle_state.as_str(),
        "Canonicalized" | "BiddingActive" | "BiddingClosed"
    ) {
        return Err(translate_domain_error(
            DomainError::CannotOverrideBeforeCanonicalization {
                current_state: lifecycle_state,
            },
        ));
    }

    // Perform override
    let (previous_eligibility, was_already_overridden) = persistence
        .override_eligibility(bid_year_id, request.user_id, request.can_bid, reason)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to override eligibility: {e}"),
        })?;

    // Create and persist audit event
    let actor = authenticated_actor.to_audit_actor(operator);
    let cause = Cause::new(
        String::from("override_eligibility"),
        format!("Override eligibility for user {user_initials}"),
    );

    let action = Action::new(
        String::from("UserEligibilityOverridden"),
        Some(format!(
            "user_id={}, previous_eligibility={}, new_eligibility={}, reason={}, was_overridden={}",
            request.user_id, previous_eligibility, request.can_bid, reason, was_already_overridden
        )),
    );

    let before = StateSnapshot::new(format!("can_bid={previous_eligibility}"));
    let after = StateSnapshot::new(format!("can_bid={}", request.can_bid));

    let year = persistence
        .get_bid_year_from_id(bid_year_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to get bid year: {e}"),
        })?;
    let bid_year = BidYear::new(year);
    let area = Area::new("_override");

    let audit_event = AuditEvent::new(actor, cause, action, before, after, bid_year, area);

    let event_id =
        persistence
            .persist_audit_event(&audit_event)
            .map_err(|e| ApiError::Internal {
                message: format!("Failed to persist audit event: {e}"),
            })?;

    Ok(OverrideEligibilityResponse {
        audit_event_id: event_id,
        message: format!(
            "Eligibility overridden for user {user_initials} (audit event {event_id})"
        ),
    })
}

/// Override a user's bid order after canonicalization.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The override request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data
///
/// # Returns
///
/// Returns the audit event ID on success.
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not an admin
/// - The lifecycle state is not >= Canonicalized
/// - The override reason is invalid
/// - The bid order is invalid (must be positive if provided)
/// - The canonical record does not exist
#[allow(dead_code)]
pub fn override_bid_order(
    persistence: &mut SqlitePersistence,
    request: &OverrideBidOrderRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
) -> Result<OverrideBidOrderResponse, ApiError> {
    // Enforce authorization - only admins can perform overrides
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("override_bid_order"),
            required_role: String::from("Admin"),
        });
    }

    // Validate override reason (min 10 chars)
    let reason = request.reason.trim();
    if reason.len() < 10 {
        return Err(translate_domain_error(DomainError::InvalidOverrideReason {
            reason: request.reason.clone(),
        }));
    }

    // Validate bid order if provided
    if let Some(order) = request.bid_order
        && order <= 0
    {
        return Err(translate_domain_error(DomainError::InvalidBidOrder {
            reason: format!("Bid order must be positive (got: {order})"),
        }));
    }

    // Get user details
    let (bid_year_id, user_initials): (i64, String) =
        persistence.get_user_details(request.user_id).map_err(|_| {
            let user_id = request.user_id;
            ApiError::ResourceNotFound {
                resource_type: String::from("User"),
                message: format!("User with ID {user_id} not found"),
            }
        })?;

    // Check lifecycle state >= Canonicalized
    let lifecycle_state =
        persistence
            .get_lifecycle_state(bid_year_id)
            .map_err(|e| ApiError::Internal {
                message: format!("Failed to get lifecycle state: {e}"),
            })?;

    if !matches!(
        lifecycle_state.as_str(),
        "Canonicalized" | "BiddingActive" | "BiddingClosed"
    ) {
        return Err(translate_domain_error(
            DomainError::CannotOverrideBeforeCanonicalization {
                current_state: lifecycle_state,
            },
        ));
    }

    // Perform override
    let (previous_bid_order, was_already_overridden) = persistence
        .override_bid_order(bid_year_id, request.user_id, request.bid_order, reason)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to override bid order: {e}"),
        })?;

    // Create and persist audit event
    let actor = authenticated_actor.to_audit_actor(operator);
    let cause = Cause::new(
        String::from("override_bid_order"),
        format!("Override bid order for user {user_initials}"),
    );

    let action = Action::new(
        String::from("UserBidOrderOverridden"),
        Some(format!(
            "user_id={}, previous_bid_order={:?}, new_bid_order={:?}, reason={}, was_overridden={}",
            request.user_id, previous_bid_order, request.bid_order, reason, was_already_overridden
        )),
    );

    let before = StateSnapshot::new(format!("bid_order={previous_bid_order:?}"));
    let after = StateSnapshot::new(format!("bid_order={:?}", request.bid_order));

    let year = persistence
        .get_bid_year_from_id(bid_year_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to get bid year: {e}"),
        })?;
    let bid_year = BidYear::new(year);
    let area = Area::new("_override");

    let audit_event = AuditEvent::new(actor, cause, action, before, after, bid_year, area);

    let event_id =
        persistence
            .persist_audit_event(&audit_event)
            .map_err(|e| ApiError::Internal {
                message: format!("Failed to persist audit event: {e}"),
            })?;

    Ok(OverrideBidOrderResponse {
        audit_event_id: event_id,
        message: format!("Bid order overridden for user {user_initials} (audit event {event_id})"),
    })
}

/// Override a user's bid window after canonicalization.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The override request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data
///
/// # Returns
///
/// Returns the audit event ID on success.
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not an admin
/// - The lifecycle state is not >= Canonicalized
/// - The override reason is invalid
/// - The bid window dates are invalid (start > end, partial window)
/// - The canonical record does not exist
#[allow(clippy::too_many_lines)]
#[allow(dead_code)]
pub fn override_bid_window(
    persistence: &mut SqlitePersistence,
    request: &OverrideBidWindowRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
) -> Result<OverrideBidWindowResponse, ApiError> {
    // Enforce authorization - only admins can perform overrides
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("override_bid_window"),
            required_role: String::from("Admin"),
        });
    }

    // Validate override reason (min 10 chars)
    let reason = request.reason.trim();
    if reason.len() < 10 {
        return Err(translate_domain_error(DomainError::InvalidOverrideReason {
            reason: request.reason.clone(),
        }));
    }

    // Validate bid window - both must be present or both must be None
    match (&request.window_start, &request.window_end) {
        (Some(start), Some(end)) => {
            // Parse dates to validate format and ordering
            let start_date = time::Date::parse(
                start,
                time::macros::format_description!("[year]-[month]-[day]"),
            )
            .map_err(|e| {
                translate_domain_error(DomainError::DateParseError {
                    date_string: start.clone(),
                    error: e.to_string(),
                })
            })?;
            let end_date = time::Date::parse(
                end,
                time::macros::format_description!("[year]-[month]-[day]"),
            )
            .map_err(|e| {
                translate_domain_error(DomainError::DateParseError {
                    date_string: end.clone(),
                    error: e.to_string(),
                })
            })?;

            if start_date > end_date {
                return Err(translate_domain_error(DomainError::InvalidBidWindow {
                    reason: format!("Window start date ({start}) must be <= end date ({end})"),
                }));
            }
        }
        (None, None) => {
            // Both None is valid (clears the window)
        }
        _ => {
            return Err(translate_domain_error(DomainError::InvalidBidWindow {
                reason: String::from(
                    "Both window_start and window_end must be provided or both must be null",
                ),
            }));
        }
    }

    // Get user details
    let (bid_year_id, user_initials): (i64, String) =
        persistence.get_user_details(request.user_id).map_err(|_| {
            let user_id = request.user_id;
            ApiError::ResourceNotFound {
                resource_type: String::from("User"),
                message: format!("User with ID {user_id} not found"),
            }
        })?;

    // Check lifecycle state >= Canonicalized
    let lifecycle_state =
        persistence
            .get_lifecycle_state(bid_year_id)
            .map_err(|e| ApiError::Internal {
                message: format!("Failed to get lifecycle state: {e}"),
            })?;

    if !matches!(
        lifecycle_state.as_str(),
        "Canonicalized" | "BiddingActive" | "BiddingClosed"
    ) {
        return Err(translate_domain_error(
            DomainError::CannotOverrideBeforeCanonicalization {
                current_state: lifecycle_state,
            },
        ));
    }

    // Perform override
    let (previous_start, previous_end, was_already_overridden) = persistence
        .override_bid_window(
            bid_year_id,
            request.user_id,
            request.window_start.as_ref(),
            request.window_end.as_ref(),
            reason,
        )
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to override bid window: {e}"),
        })?;

    // Create and persist audit event
    let actor = authenticated_actor.to_audit_actor(operator);
    let cause = Cause::new(
        String::from("override_bid_window"),
        format!("Override bid window for user {user_initials}"),
    );

    let action = Action::new(
        String::from("UserBidWindowOverridden"),
        Some(format!(
            "user_id={}, previous_start={:?}, previous_end={:?}, new_start={:?}, new_end={:?}, reason={}, was_overridden={}",
            request.user_id,
            previous_start,
            previous_end,
            request.window_start,
            request.window_end,
            reason,
            was_already_overridden
        )),
    );

    let before = StateSnapshot::new(format!(
        "window_start={previous_start:?}, window_end={previous_end:?}"
    ));
    let after = StateSnapshot::new(format!(
        "window_start={:?}, window_end={:?}",
        request.window_start, request.window_end
    ));

    let year = persistence
        .get_bid_year_from_id(bid_year_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to get bid year: {e}"),
        })?;
    let bid_year = BidYear::new(year);
    let area = Area::new("_override");

    let audit_event = AuditEvent::new(actor, cause, action, before, after, bid_year, area);

    let event_id =
        persistence
            .persist_audit_event(&audit_event)
            .map_err(|e| ApiError::Internal {
                message: format!("Failed to persist audit event: {e}"),
            })?;

    Ok(OverrideBidWindowResponse {
        audit_event_id: event_id,
        message: format!("Bid window overridden for user {user_initials} (audit event {event_id})"),
    })
}
