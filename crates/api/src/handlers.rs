// Copyright (C) 2026 Fred Clausen
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

//! API handler functions for state-changing and read-only operations.

use zab_bid::{
    BootstrapMetadata, BootstrapResult, Command, State, TransitionResult, apply, apply_bootstrap,
    validate_area_exists, validate_bid_year_exists,
};
use zab_bid_audit::{Actor, AuditEvent, Cause};
use zab_bid_domain::{Area, BidYear, Crew, Initials, SeniorityData, UserType};

use crate::auth::{AuthenticatedActor, AuthorizationService, Role};
use crate::error::{ApiError, translate_core_error, translate_domain_error};
use crate::request_response::{
    CreateAreaRequest, CreateBidYearRequest, ListAreasRequest, ListAreasResponse,
    ListBidYearsResponse, ListUsersResponse, RegisterUserRequest, RegisterUserResponse, UserInfo,
};

/// The result of an API operation that includes both the response and the audit event.
///
/// This ensures that successful API operations always produce an audit trail.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ApiResult<T> {
    /// The API response.
    pub response: T,
    /// The audit event generated by this operation.
    pub audit_event: AuditEvent,
    /// The new state after the operation.
    pub new_state: State,
}

/// Registers a new user via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Translates the API request into a core command
/// - Applies the command to the current state
/// - Translates any errors to API errors
/// - Returns the API response with audit event on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `state` - The current system state
/// * `request` - The API request to register a user
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(ApiResult<RegisterUserResponse>)` on success
/// * `Err(ApiError)` if unauthorized, the request is invalid, or a domain rule is violated
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - Any field validation fails
/// - The initials are already in use within the bid year
pub fn register_user(
    metadata: &BootstrapMetadata,
    state: &State,
    request: RegisterUserRequest,
    authenticated_actor: &AuthenticatedActor,
    cause: Cause,
) -> Result<ApiResult<RegisterUserResponse>, ApiError> {
    // Enforce authorization before executing command
    AuthorizationService::authorize_register_user(authenticated_actor)?;

    // Convert authenticated actor to audit actor for attribution
    let actor: Actor = authenticated_actor.to_audit_actor();
    // Translate API request into domain types
    let bid_year: BidYear = BidYear::new(request.bid_year);
    let initials: Initials = Initials::new(&request.initials);
    let area: Area = Area::new(&request.area);

    // Parse user type
    let user_type: UserType =
        UserType::parse(&request.user_type).map_err(translate_domain_error)?;

    // Parse optional crew
    let crew: Option<Crew> = match request.crew {
        Some(crew_num) => Some(Crew::new(crew_num).map_err(translate_domain_error)?),
        None => None,
    };

    let seniority_data: SeniorityData = SeniorityData::new(
        request.cumulative_natca_bu_date,
        request.natca_bu_date,
        request.eod_faa_date,
        request.service_computation_date,
        request.lottery_value,
    );

    // Create core command
    let command: Command = Command::RegisterUser {
        bid_year: bid_year.clone(),
        initials: initials.clone(),
        name: request.name.clone(),
        area,
        user_type,
        crew,
        seniority_data,
    };

    // Apply command via core transition
    let transition_result: TransitionResult =
        apply(metadata, state, command, actor, cause).map_err(translate_core_error)?;

    // Translate to API response
    let response: RegisterUserResponse = RegisterUserResponse {
        bid_year: bid_year.year(),
        initials: initials.value().to_string(),
        name: request.name,
        message: format!(
            "Successfully registered user '{}' for bid year {}",
            initials.value(),
            bid_year.year()
        ),
    };

    Ok(ApiResult {
        response,
        audit_event: transition_result.audit_event,
        new_state: transition_result.new_state,
    })
}

/// Creates a checkpoint via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a checkpoint command
/// - Applies the command to the current state
/// - Returns the transition result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `state` - The current system state
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(TransitionResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The command execution fails
pub fn checkpoint(
    metadata: &BootstrapMetadata,
    state: &State,
    authenticated_actor: &AuthenticatedActor,
    cause: Cause,
) -> Result<TransitionResult, ApiError> {
    // Enforce authorization before executing command
    AuthorizationService::authorize_checkpoint(authenticated_actor)?;

    // Convert authenticated actor to audit actor for attribution
    let actor: Actor = authenticated_actor.to_audit_actor();

    // Create and apply checkpoint command
    let command: Command = Command::Checkpoint;
    let transition_result: TransitionResult =
        apply(metadata, state, command, actor, cause).map_err(translate_core_error)?;

    Ok(transition_result)
}

/// Finalizes a round via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a finalize command
/// - Applies the command to the current state
/// - Returns the transition result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `state` - The current system state
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(TransitionResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The command execution fails
pub fn finalize(
    metadata: &BootstrapMetadata,
    state: &State,
    authenticated_actor: &AuthenticatedActor,
    cause: Cause,
) -> Result<TransitionResult, ApiError> {
    // Enforce authorization before executing command
    AuthorizationService::authorize_finalize(authenticated_actor)?;

    // Convert authenticated actor to audit actor for attribution
    let actor: Actor = authenticated_actor.to_audit_actor();

    // Create and apply finalize command
    let command: Command = Command::Finalize;
    let transition_result: TransitionResult =
        apply(metadata, state, command, actor, cause).map_err(translate_core_error)?;

    Ok(transition_result)
}

/// Rolls back to a specific event via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a rollback command
/// - Applies the command to the current state
/// - Returns the transition result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `state` - The current system state
/// * `target_event_id` - The event ID to rollback to
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(TransitionResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The command execution fails
pub fn rollback(
    metadata: &BootstrapMetadata,
    state: &State,
    target_event_id: i64,
    authenticated_actor: &AuthenticatedActor,
    cause: Cause,
) -> Result<TransitionResult, ApiError> {
    // Enforce authorization before executing command
    AuthorizationService::authorize_rollback(authenticated_actor)?;

    // Convert authenticated actor to audit actor for attribution
    let actor: Actor = authenticated_actor.to_audit_actor();

    // Create and apply rollback command
    let command: Command = Command::RollbackToEventId { target_event_id };
    let transition_result: TransitionResult =
        apply(metadata, state, command, actor, cause).map_err(translate_core_error)?;

    Ok(transition_result)
}

/// Creates a new bid year via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a `CreateBidYear` command
/// - Applies the command to the bootstrap metadata
/// - Returns the bootstrap result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `request` - The API request to create a bid year
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(BootstrapResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The bid year already exists
/// - The bid year value is invalid
pub fn create_bid_year(
    metadata: &BootstrapMetadata,
    request: &CreateBidYearRequest,
    authenticated_actor: &AuthenticatedActor,
    cause: Cause,
) -> Result<BootstrapResult, ApiError> {
    // Enforce authorization - only admins can create bid years
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("create_bid_year"),
            required_role: String::from("Admin"),
        });
    }

    // Convert authenticated actor to audit actor for attribution
    let actor: Actor = authenticated_actor.to_audit_actor();

    // Create command
    let command: Command = Command::CreateBidYear { year: request.year };

    // Apply command via core bootstrap
    let bootstrap_result: BootstrapResult =
        apply_bootstrap(metadata, command, actor, cause).map_err(translate_core_error)?;

    Ok(bootstrap_result)
}

/// Creates a new area via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a `CreateArea` command
/// - Applies the command to the bootstrap metadata
/// - Returns the bootstrap result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `request` - The API request to create an area
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(BootstrapResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The bid year does not exist
/// - The area already exists in the bid year
pub fn create_area(
    metadata: &BootstrapMetadata,
    request: CreateAreaRequest,
    authenticated_actor: &AuthenticatedActor,
    cause: Cause,
) -> Result<BootstrapResult, ApiError> {
    // Enforce authorization - only admins can create areas
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("create_area"),
            required_role: String::from("Admin"),
        });
    }

    // Convert authenticated actor to audit actor for attribution
    let actor: Actor = authenticated_actor.to_audit_actor();

    // Create command
    let command: Command = Command::CreateArea {
        bid_year: BidYear::new(request.bid_year),
        area_id: request.area_id,
    };

    // Apply command via core bootstrap
    let bootstrap_result: BootstrapResult =
        apply_bootstrap(metadata, command, actor, cause).map_err(translate_core_error)?;

    Ok(bootstrap_result)
}

/// Lists all bid years.
///
/// This operation never fails and requires no authorization.
/// Returns an empty list if no bid years have been created.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
///
/// # Returns
///
/// A response containing all bid years.
#[must_use]
pub fn list_bid_years(metadata: &BootstrapMetadata) -> ListBidYearsResponse {
    let bid_years: Vec<u16> = metadata.bid_years.iter().map(BidYear::year).collect();

    ListBidYearsResponse { bid_years }
}

/// Lists all areas for a given bid year.
///
/// This is a read-only operation that requires no authorization.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `request` - The list areas request
///
/// # Returns
///
/// * `Ok(ListAreasResponse)` containing all areas for the bid year
/// * `Err(ApiError)` if the bid year does not exist
///
/// # Errors
///
/// Returns an error if the bid year has not been created.
pub fn list_areas(
    metadata: &BootstrapMetadata,
    request: &ListAreasRequest,
) -> Result<ListAreasResponse, ApiError> {
    let bid_year: BidYear = BidYear::new(request.bid_year);

    // Validate bid year exists before querying
    validate_bid_year_exists(metadata, &bid_year).map_err(translate_domain_error)?;

    let areas: Vec<String> = metadata
        .areas
        .iter()
        .filter(|(by, _)| by.year() == bid_year.year())
        .map(|(_, area)| area.id().to_string())
        .collect();

    Ok(ListAreasResponse {
        bid_year: request.bid_year,
        areas,
    })
}

/// Lists all users for a given bid year and area.
///
/// This is a read-only operation that requires no authorization.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `bid_year` - The bid year to list users for
/// * `area` - The area to list users for
/// * `state` - The current state for the bid year and area
///
/// # Returns
///
/// * `Ok(ListUsersResponse)` containing all users for the scope
/// * `Err(ApiError)` if the bid year or area does not exist
///
/// # Errors
///
/// Returns an error if:
/// - The bid year has not been created
/// - The area has not been created in the bid year
pub fn list_users(
    metadata: &BootstrapMetadata,
    bid_year: &BidYear,
    area: &Area,
    state: &State,
) -> Result<ListUsersResponse, ApiError> {
    // Validate bid year and area exist before processing
    validate_area_exists(metadata, bid_year, area).map_err(translate_domain_error)?;

    let users: Vec<UserInfo> = state
        .users
        .iter()
        .map(|user| UserInfo {
            initials: user.initials.value().to_string(),
            name: user.name.clone(),
            crew: user.crew.as_ref().map(Crew::number),
        })
        .collect();

    Ok(ListUsersResponse {
        bid_year: state.bid_year.year(),
        area: state.area.id().to_string(),
        users,
    })
}

/// Gets the current state for a given bid year and area.
///
/// This is a read-only operation that requires no authorization.
/// This function validates that the bid year and area exist before
/// attempting to load state from persistence.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `bid_year` - The bid year to get state for
/// * `area` - The area to get state for
/// * `state` - The current state (if it exists)
///
/// # Returns
///
/// * `Ok(State)` - The current state for the scope
/// * `Err(ApiError)` if the bid year or area does not exist
///
/// # Errors
///
/// Returns an error if:
/// - The bid year has not been created
/// - The area has not been created in the bid year
pub fn get_current_state(
    metadata: &BootstrapMetadata,
    bid_year: &BidYear,
    area: &Area,
    state: State,
) -> Result<State, ApiError> {
    // Validate bid year and area exist before returning state
    validate_area_exists(metadata, bid_year, area).map_err(translate_domain_error)?;

    Ok(state)
}

/// Gets the historical state for a given bid year and area at a specific timestamp.
///
/// This is a read-only operation that requires no authorization.
/// This function validates that the bid year and area exist before
/// attempting to load historical state from persistence.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `bid_year` - The bid year to get state for
/// * `area` - The area to get state for
/// * `state` - The historical state (if it exists)
///
/// # Returns
///
/// * `Ok(State)` - The historical state for the scope at the timestamp
/// * `Err(ApiError)` if the bid year or area does not exist
///
/// # Errors
///
/// Returns an error if:
/// - The bid year has not been created
/// - The area has not been created in the bid year
pub fn get_historical_state(
    metadata: &BootstrapMetadata,
    bid_year: &BidYear,
    area: &Area,
    state: State,
) -> Result<State, ApiError> {
    // Validate bid year and area exist before returning state
    validate_area_exists(metadata, bid_year, area).map_err(translate_domain_error)?;

    Ok(state)
}
