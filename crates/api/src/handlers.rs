// Copyright (C) 2026 Fred Clausen
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

//! API handler functions for state-changing and read-only operations.

use std::time::{SystemTime, UNIX_EPOCH};
use zab_bid::{
    BootstrapMetadata, BootstrapResult, Command, State, TransitionResult, apply, apply_bootstrap,
    validate_area_exists, validate_bid_year_exists,
};
use zab_bid_audit::{Action, Actor, AuditEvent, Cause, StateSnapshot};
use zab_bid_domain::{
    Area, BidYear, CanonicalBidYear, Crew, Initials, LeaveAccrualResult, LeaveAvailabilityResult,
    LeaveUsage, SeniorityData, UserType, calculate_leave_accrual, calculate_leave_availability,
};
use zab_bid_persistence::{OperatorData, SqlitePersistence};

use crate::auth::{AuthenticatedActor, AuthenticationService, AuthorizationService, Role};
use crate::csv_preview::{CsvRowResult, preview_csv_users as preview_csv_users_impl};
use crate::error::{ApiError, AuthError, translate_core_error, translate_domain_error};
use crate::password_policy::PasswordPolicy;
use crate::request_response::{
    AreaCompletenessInfo, BidYearCompletenessInfo, BidYearInfo, BlockingReason,
    ChangePasswordRequest, ChangePasswordResponse, CreateAreaRequest, CreateBidYearRequest,
    CreateOperatorRequest, CreateOperatorResponse, CsvRowPreview, CsvRowStatus,
    DeleteOperatorRequest, DeleteOperatorResponse, DisableOperatorRequest, DisableOperatorResponse,
    EnableOperatorRequest, EnableOperatorResponse, GetActiveBidYearResponse,
    GetBootstrapCompletenessResponse, GetLeaveAvailabilityResponse, ListAreasRequest,
    ListAreasResponse, ListBidYearsResponse, ListOperatorsResponse, ListUsersResponse,
    LoginRequest, LoginResponse, OperatorInfo, PreviewCsvUsersRequest, PreviewCsvUsersResponse,
    RegisterUserRequest, RegisterUserResponse, ResetPasswordRequest, ResetPasswordResponse,
    SetActiveBidYearRequest, SetActiveBidYearResponse, SetExpectedAreaCountRequest,
    SetExpectedAreaCountResponse, SetExpectedUserCountRequest, SetExpectedUserCountResponse,
    UpdateUserRequest, UpdateUserResponse, UserInfo, WhoAmIResponse,
};
use zab_bid_persistence::PersistenceError;

/// The result of an API operation that includes both the response and the audit event.
///
/// This ensures that successful API operations always produce an audit trail.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ApiResult<T> {
    /// The API response.
    pub response: T,
    /// The audit event generated by this operation.
    pub audit_event: AuditEvent,
    /// The new state after the operation.
    pub new_state: State,
}

/// Registers a new user via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Translates the API request into a core command
/// - Applies the command to the current state
/// - Translates any errors to API errors
/// - Returns the API response with audit event on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `state` - The current system state
/// * `request` - The API request to register a user
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(ApiResult<RegisterUserResponse>)` on success
/// * `Err(ApiError)` if unauthorized, the request is invalid, or a domain rule is violated
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - Any field validation fails
/// - The initials are already in use within the bid year
pub fn register_user(
    metadata: &BootstrapMetadata,
    state: &State,
    request: RegisterUserRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<ApiResult<RegisterUserResponse>, ApiError> {
    // Enforce authorization before executing command
    AuthorizationService::authorize_register_user(authenticated_actor)?;

    // Convert authenticated actor to audit actor with operator information
    let actor: Actor = authenticated_actor.to_audit_actor(operator);
    // Translate API request into domain types
    let bid_year: BidYear = BidYear::new(request.bid_year);
    let initials: Initials = Initials::new(&request.initials);
    let area: Area = Area::new(&request.area);

    // Parse user type
    let user_type: UserType =
        UserType::parse(&request.user_type).map_err(translate_domain_error)?;

    // Parse optional crew
    let crew: Option<Crew> = match request.crew {
        Some(crew_num) => Some(Crew::new(crew_num).map_err(translate_domain_error)?),
        None => None,
    };

    let seniority_data: SeniorityData = SeniorityData::new(
        request.cumulative_natca_bu_date,
        request.natca_bu_date,
        request.eod_faa_date,
        request.service_computation_date,
        request.lottery_value,
    );

    // Create core command
    let command: Command = Command::RegisterUser {
        bid_year: bid_year.clone(),
        initials: initials.clone(),
        name: request.name.clone(),
        area,
        user_type,
        crew,
        seniority_data,
    };

    // Apply command via core transition
    let transition_result: TransitionResult =
        apply(metadata, state, command, actor, cause).map_err(translate_core_error)?;

    // Translate to API response
    let response: RegisterUserResponse = RegisterUserResponse {
        bid_year: bid_year.year(),
        initials: initials.value().to_string(),
        name: request.name,
        message: format!(
            "Successfully registered user '{}' for bid year {}",
            initials.value(),
            bid_year.year()
        ),
    };

    Ok(ApiResult {
        response,
        audit_event: transition_result.audit_event,
        new_state: transition_result.new_state,
    })
}

/// Creates a checkpoint via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a checkpoint command
/// - Applies the command to the current state
/// - Returns the transition result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `state` - The current system state
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(TransitionResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The command execution fails
pub fn checkpoint(
    metadata: &BootstrapMetadata,
    state: &State,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<TransitionResult, ApiError> {
    // Enforce authorization before executing command
    AuthorizationService::authorize_checkpoint(authenticated_actor)?;

    // Convert authenticated actor to audit actor with operator information
    let actor: Actor = authenticated_actor.to_audit_actor(operator);

    // Create and apply checkpoint command
    let command: Command = Command::Checkpoint;
    let transition_result: TransitionResult =
        apply(metadata, state, command, actor, cause).map_err(translate_core_error)?;

    Ok(transition_result)
}

/// Finalizes a round via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a finalize command
/// - Applies the command to the current state
/// - Returns the transition result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `state` - The current system state
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(TransitionResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The command execution fails
pub fn finalize(
    metadata: &BootstrapMetadata,
    state: &State,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<TransitionResult, ApiError> {
    // Enforce authorization before executing command
    AuthorizationService::authorize_finalize(authenticated_actor)?;

    // Convert authenticated actor to audit actor with operator information
    let actor: Actor = authenticated_actor.to_audit_actor(operator);

    // Create and apply finalize command
    let command: Command = Command::Finalize;
    let transition_result: TransitionResult =
        apply(metadata, state, command, actor, cause).map_err(translate_core_error)?;

    Ok(transition_result)
}

/// Rolls back to a specific event via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a rollback command
/// - Applies the command to the current state
/// - Returns the transition result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `state` - The current system state
/// * `target_event_id` - The event ID to rollback to
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(TransitionResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The command execution fails
pub fn rollback(
    metadata: &BootstrapMetadata,
    state: &State,
    target_event_id: i64,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<TransitionResult, ApiError> {
    // Enforce authorization before executing command
    AuthorizationService::authorize_rollback(authenticated_actor)?;

    // Convert authenticated actor to audit actor with operator information
    let actor: Actor = authenticated_actor.to_audit_actor(operator);

    // Create and apply rollback command
    let command: Command = Command::RollbackToEventId { target_event_id };
    let transition_result: TransitionResult =
        apply(metadata, state, command, actor, cause).map_err(translate_core_error)?;

    Ok(transition_result)
}

/// Creates a new bid year via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a `CreateBidYear` command
/// - Applies the command to the bootstrap metadata
/// - Returns the bootstrap result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `request` - The API request to create a bid year
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(BootstrapResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The bid year already exists
/// - The bid year value is invalid
pub fn create_bid_year(
    metadata: &BootstrapMetadata,
    request: &CreateBidYearRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<BootstrapResult, ApiError> {
    // Enforce authorization - only admins can create bid years
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("create_bid_year"),
            required_role: String::from("Admin"),
        });
    }

    // Convert authenticated actor to audit actor with operator information
    let actor: Actor = authenticated_actor.to_audit_actor(operator);

    // Create command with canonical metadata
    let command: Command = Command::CreateBidYear {
        year: request.year,
        start_date: request.start_date,
        num_pay_periods: request.num_pay_periods,
    };

    // Apply command via core bootstrap
    let bootstrap_result: BootstrapResult =
        apply_bootstrap(metadata, command, actor, cause).map_err(translate_core_error)?;

    Ok(bootstrap_result)
}

/// Creates a new area via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a `CreateArea` command
/// - Applies the command to the bootstrap metadata
/// - Returns the bootstrap result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `request` - The API request to create an area
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(BootstrapResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The bid year does not exist
/// - The area already exists in the bid year
pub fn create_area(
    metadata: &BootstrapMetadata,
    request: &CreateAreaRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<BootstrapResult, ApiError> {
    // Enforce authorization - only admins can create areas
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("create_area"),
            required_role: String::from("Admin"),
        });
    }

    // Convert authenticated actor to audit actor with operator information
    let actor: Actor = authenticated_actor.to_audit_actor(operator);

    // Create command
    let command: Command = Command::CreateArea {
        bid_year: BidYear::new(request.bid_year),
        area_id: request.area_id.clone(),
    };

    // Apply command via core bootstrap
    let bootstrap_result: BootstrapResult =
        apply_bootstrap(metadata, command, actor, cause).map_err(translate_core_error)?;

    Ok(bootstrap_result)
}

/// Lists all bid years with their canonical metadata.
///
/// This operation never fails and requires no authorization.
/// Returns an empty list if no bid years have been created.
///
/// # Arguments
///
/// * `canonical_bid_years` - The list of canonical bid years from persistence
///
/// # Returns
///
/// A response containing all bid years with canonical metadata.
///
/// # Errors
///
/// Returns an error if end date derivation fails due to date arithmetic overflow.
pub fn list_bid_years(
    canonical_bid_years: &[CanonicalBidYear],
) -> Result<ListBidYearsResponse, ApiError> {
    let bid_years: Result<Vec<BidYearInfo>, ApiError> = canonical_bid_years
        .iter()
        .map(|c| {
            let end_date: time::Date = c.end_date().map_err(translate_domain_error)?;
            Ok(BidYearInfo {
                year: c.year(),
                start_date: c.start_date(),
                num_pay_periods: c.num_pay_periods(),
                end_date,
                area_count: 0,       // Will be populated by server layer
                total_user_count: 0, // Will be populated by server layer
            })
        })
        .collect();

    Ok(ListBidYearsResponse {
        bid_years: bid_years?,
    })
}

/// Lists all areas for a given bid year.
///
/// This is a read-only operation that requires no authorization.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `request` - The list areas request
///
/// # Returns
///
/// * `Ok(ListAreasResponse)` containing all areas for the bid year
/// * `Err(ApiError)` if the bid year does not exist
///
/// # Errors
///
/// Returns an error if the bid year has not been created.
pub fn list_areas(
    metadata: &BootstrapMetadata,
    request: &ListAreasRequest,
) -> Result<ListAreasResponse, ApiError> {
    let bid_year: BidYear = BidYear::new(request.bid_year);

    // Validate bid year exists before querying
    validate_bid_year_exists(metadata, &bid_year).map_err(translate_domain_error)?;

    let areas: Vec<crate::request_response::AreaInfo> = metadata
        .areas
        .iter()
        .filter(|(by, _)| by.year() == bid_year.year())
        .map(|(_, area)| crate::request_response::AreaInfo {
            area_id: area.id().to_string(),
            user_count: 0, // Will be populated by server layer with actual counts
        })
        .collect();

    Ok(ListAreasResponse {
        bid_year: request.bid_year,
        areas,
    })
}

/// Lists all users for a given bid year and area.
///
/// This is a read-only operation that requires no authorization.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `bid_year` - The bid year to list users for
/// * `area` - The area to list users for
/// * `state` - The current state for the bid year and area
///
/// # Returns
///
/// * `Ok(ListUsersResponse)` containing all users for the scope
/// * `Err(ApiError)` if the bid year or area does not exist
///
/// # Errors
///
/// Returns an error if:
/// - The bid year has not been created
/// - The area has not been created in the bid year
pub fn list_users(
    metadata: &BootstrapMetadata,
    canonical_bid_years: &[CanonicalBidYear],
    bid_year: &BidYear,
    area: &Area,
    state: &State,
) -> Result<ListUsersResponse, ApiError> {
    // Validate bid year and area exist before processing
    validate_area_exists(metadata, bid_year, area).map_err(translate_domain_error)?;

    // Find the canonical bid year metadata for leave calculations
    let canonical_bid_year: &CanonicalBidYear = canonical_bid_years
        .iter()
        .find(|c| c.year() == bid_year.year())
        .ok_or_else(|| {
            translate_domain_error(zab_bid_domain::DomainError::InvalidBidYear(format!(
                "Bid year {} not found",
                bid_year.year()
            )))
        })?;

    let users: Vec<UserInfo> = state
        .users
        .iter()
        .map(|user| {
            // Calculate leave accrual for this user
            let leave_accrual_result: LeaveAccrualResult =
                calculate_leave_accrual(user, canonical_bid_year).unwrap_or_else(|_| {
                    LeaveAccrualResult {
                        total_hours: 0,
                        total_days: 0,
                        rounded_up: false,
                        breakdown: vec![],
                    }
                });

            let earned_hours: u16 = leave_accrual_result.total_hours;
            let earned_days: u16 = leave_accrual_result.total_days;

            // Calculate availability
            // For Phase 11, we don't have bid records yet, so usage is empty
            let availability: LeaveAvailabilityResult =
                calculate_leave_availability(&leave_accrual_result, std::iter::empty())
                    .unwrap_or_else(|_| LeaveAvailabilityResult {
                        earned_hours,
                        earned_days,
                        used_hours: 0,
                        remaining_hours: i32::from(earned_hours),
                        remaining_days: i32::from(earned_days),
                        is_exhausted: false,
                        is_overdrawn: false,
                    });

            UserInfo {
                initials: user.initials.value().to_string(),
                name: user.name.clone(),
                crew: user.crew.as_ref().map(Crew::number),
                user_type: user.user_type.as_str().to_string(),
                earned_hours,
                earned_days,
                remaining_hours: availability.remaining_hours,
                remaining_days: availability.remaining_days,
                is_exhausted: availability.is_exhausted,
                is_overdrawn: availability.is_overdrawn,
            }
        })
        .collect();

    Ok(ListUsersResponse {
        bid_year: state.bid_year.year(),
        area: state.area.id().to_string(),
        users,
    })
}

/// Gets the current state for a given bid year and area.
///
/// This is a read-only operation that requires no authorization.
/// This function validates that the bid year and area exist before
/// attempting to load state from persistence.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `bid_year` - The bid year to get state for
/// * `area` - The area to get state for
/// * `state` - The current state (if it exists)
///
/// # Returns
///
/// * `Ok(State)` - The current state for the scope
/// * `Err(ApiError)` if the bid year or area does not exist
///
/// # Errors
///
/// Returns an error if:
/// - The bid year has not been created
/// - The area has not been created in the bid year
pub fn get_current_state(
    metadata: &BootstrapMetadata,
    bid_year: &BidYear,
    area: &Area,
    state: State,
) -> Result<State, ApiError> {
    // Validate bid year and area exist before returning state
    validate_area_exists(metadata, bid_year, area).map_err(translate_domain_error)?;

    Ok(state)
}

/// Gets the historical state for a given bid year and area at a specific timestamp.
///
/// This is a read-only operation that requires no authorization.
/// This function validates that the bid year and area exist before
/// attempting to load historical state from persistence.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `bid_year` - The bid year to get state for
/// * `area` - The area to get state for
/// * `state` - The historical state (if it exists)
///
/// # Returns
///
/// * `Ok(State)` - The historical state for the scope at the timestamp
/// * `Err(ApiError)` if the bid year or area does not exist
///
/// # Errors
///
/// Returns an error if:
/// - The bid year has not been created
/// - The area has not been created in the bid year
pub fn get_historical_state(
    metadata: &BootstrapMetadata,
    bid_year: &BidYear,
    area: &Area,
    state: State,
) -> Result<State, ApiError> {
    // Validate bid year and area exist before returning state
    validate_area_exists(metadata, bid_year, area).map_err(translate_domain_error)?;

    Ok(state)
}

/// Gets leave availability for a specific user.
///
/// This is a read-only operation that:
/// - Validates the bid year and area exist
/// - Finds the specified user
/// - Calculates leave accrual using Phase 9 logic
/// - Retrieves leave usage records (currently none exist in persistence)
/// - Calculates remaining leave availability
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `canonical_bid_year` - The canonical bid year for accrual calculation
/// * `area` - The area
/// * `initials` - The user's initials
/// * `state` - The current state
///
/// # Returns
///
/// * `Ok(GetLeaveAvailabilityResponse)` - The leave availability information
/// * `Err(ApiError)` if the bid year, area, or user does not exist
///
/// # Errors
///
/// Returns an error if:
/// - The bid year does not exist
/// - The area does not exist in the bid year
/// - The user does not exist in the area
/// - Leave accrual calculation fails
/// - Leave availability calculation fails
pub fn get_leave_availability(
    metadata: &BootstrapMetadata,
    canonical_bid_year: &CanonicalBidYear,
    area: &Area,
    initials: &Initials,
    state: &State,
) -> Result<GetLeaveAvailabilityResponse, ApiError> {
    let bid_year: BidYear = BidYear::new(canonical_bid_year.year());

    // Validate bid year and area exist
    validate_area_exists(metadata, &bid_year, area).map_err(translate_domain_error)?;

    // Find the user
    let user = state
        .users
        .iter()
        .find(|u| u.initials == *initials)
        .ok_or_else(|| ApiError::ResourceNotFound {
            resource_type: String::from("User"),
            message: format!(
                "User with initials '{}' not found in bid year {} area {}",
                initials.value(),
                bid_year.year(),
                area.id()
            ),
        })?;

    // Calculate leave accrual using Phase 9
    let accrual =
        calculate_leave_accrual(user, canonical_bid_year).map_err(translate_domain_error)?;

    // Retrieve leave usage records
    // Note: For Phase 10, no persistence for leave usage exists yet.
    // We pass an empty iterator, which means all earned leave is available.
    let usage_records: Vec<LeaveUsage> = Vec::new();

    // Calculate leave availability
    let availability: LeaveAvailabilityResult =
        calculate_leave_availability(&accrual, usage_records).map_err(translate_domain_error)?;

    // Build explanation
    let explanation: String = format!(
        "Leave accrual calculated for user '{}' in bid year {}. \
         Earned: {} hours ({} days). Used: {} hours. \
         Remaining: {} hours ({} days).{}{}",
        initials.value(),
        bid_year.year(),
        availability.earned_hours,
        availability.earned_days,
        availability.used_hours,
        availability.remaining_hours,
        availability.remaining_days,
        if availability.is_exhausted {
            " Leave fully exhausted."
        } else {
            ""
        },
        if availability.is_overdrawn {
            " Leave balance is overdrawn."
        } else {
            ""
        }
    );

    Ok(GetLeaveAvailabilityResponse {
        bid_year: bid_year.year(),
        initials: initials.value().to_string(),
        earned_hours: availability.earned_hours,
        earned_days: availability.earned_days,
        used_hours: availability.used_hours,
        remaining_hours: availability.remaining_hours,
        remaining_days: availability.remaining_days,
        is_exhausted: availability.is_exhausted,
        is_overdrawn: availability.is_overdrawn,
        explanation,
    })
}

/// Gets a comprehensive bootstrap status summary.
///
/// This is a read-only operation that provides aggregated information
/// about all bid years and areas in the system.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `area_counts` - Area counts per bid year
/// * `user_counts_by_year` - Total user counts per bid year
/// * `user_counts_by_area` - User counts per (`bid_year`, `area_id`)
///
/// # Returns
///
/// * `Ok(BootstrapStatusResponse)` containing all system status information
///
/// # Errors
///
/// This function does not currently return errors, but the return type supports
/// future error conditions.
///
/// This endpoint is useful for operators to get a complete picture of the
/// system state in a single API call.
pub fn get_bootstrap_status(
    metadata: &BootstrapMetadata,
    area_counts: &[(u16, usize)],
    user_counts_by_year: &[(u16, usize)],
    user_counts_by_area: &[(u16, String, usize)],
) -> Result<crate::request_response::BootstrapStatusResponse, ApiError> {
    use crate::request_response::{AreaStatusInfo, BidYearStatusInfo, BootstrapStatusResponse};

    // Build bid year summaries
    let bid_years: Vec<BidYearStatusInfo> = metadata
        .bid_years
        .iter()
        .map(|bid_year| {
            let year: u16 = bid_year.year();
            let area_count: usize = area_counts
                .iter()
                .find(|(y, _)| *y == year)
                .map_or(0, |(_, count)| *count);
            let total_user_count: usize = user_counts_by_year
                .iter()
                .find(|(y, _)| *y == year)
                .map_or(0, |(_, count)| *count);

            BidYearStatusInfo {
                year,
                area_count,
                total_user_count,
            }
        })
        .collect();

    // Build area summaries
    let areas: Vec<AreaStatusInfo> = metadata
        .areas
        .iter()
        .map(|(bid_year, area)| {
            let year: u16 = bid_year.year();
            let area_id: String = area.id().to_string();
            let user_count: usize = user_counts_by_area
                .iter()
                .find(|(y, a, _)| *y == year && a == &area_id)
                .map_or(0, |(_, _, count)| *count);

            AreaStatusInfo {
                bid_year: year,
                area_id,
                user_count,
            }
        })
        .collect();

    Ok(BootstrapStatusResponse { bid_years, areas })
}

// ========================================================================
// Authentication Handlers (Phase 14)
// ========================================================================

/// Authenticates an operator and creates a session.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The login request
///
/// # Returns
///
/// * `Ok(LoginResponse)` on success with session token
/// * `Err(ApiError)` if authentication fails
///
/// # Errors
///
/// Returns an error if:
/// - The operator does not exist
/// - The operator is disabled
/// - Database operations fail
pub fn login(
    persistence: &mut SqlitePersistence,
    request: &LoginRequest,
) -> Result<LoginResponse, ApiError> {
    let (session_token, _authenticated_actor, operator): (
        String,
        AuthenticatedActor,
        OperatorData,
    ) = AuthenticationService::login(persistence, &request.login_name, &request.password)?;

    // Get session expiration from the session we just created
    let session: Option<zab_bid_persistence::SessionData> = persistence
        .get_session_by_token(&session_token)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to retrieve session: {e}"),
        })?;

    let expires_at: String = session
        .ok_or_else(|| ApiError::Internal {
            message: String::from("Session not found after creation"),
        })?
        .expires_at;

    Ok(LoginResponse {
        session_token,
        login_name: operator.login_name,
        display_name: operator.display_name,
        role: operator.role,
        expires_at,
    })
}

/// Logs out by deleting the session.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `session_token` - The session token to delete
///
/// # Errors
///
/// Returns an error if the logout fails.
pub fn logout(persistence: &mut SqlitePersistence, session_token: &str) -> Result<(), ApiError> {
    AuthenticationService::logout(persistence, session_token)?;
    Ok(())
}

/// Returns the current operator's information.
///
/// # Arguments
///
/// * `operator` - The operator data from the validated session
///
/// # Returns
///
/// * `Ok(WhoAmIResponse)` with operator information
#[must_use]
pub fn whoami(operator: &OperatorData) -> WhoAmIResponse {
    WhoAmIResponse {
        login_name: operator.login_name.clone(),
        display_name: operator.display_name.clone(),
        role: operator.role.clone(),
        is_disabled: operator.is_disabled,
    }
}

/// Creates a new operator.
///
/// Only Admin actors may create operators.
/// Emits an audit event on success.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The create operator request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data for audit attribution
/// * `cause` - The cause for this action
///
/// # Returns
///
/// * `Ok(CreateOperatorResponse)` on success
/// * `Err(ApiError)` if unauthorized or creation fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The login name already exists
/// - The role is invalid
/// - Database operations fail
pub fn create_operator(
    persistence: &mut SqlitePersistence,
    request: CreateOperatorRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<CreateOperatorResponse, ApiError> {
    // Enforce authorization before executing command
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("create_operator"),
            required_role: String::from("Admin"),
        });
    }

    // Validate role
    if request.role != "Admin" && request.role != "Bidder" {
        return Err(ApiError::InvalidInput {
            field: String::from("role"),
            message: format!(
                "Invalid role: {}. Must be 'Admin' or 'Bidder'",
                request.role
            ),
        });
    }

    // Validate password policy
    let policy: PasswordPolicy = PasswordPolicy::default();
    policy.validate(
        &request.password,
        &request.password_confirmation,
        &request.login_name,
        &request.display_name,
    )?;

    // Create operator with validated password
    let operator_id: i64 = persistence
        .create_operator(
            &request.login_name,
            &request.display_name,
            &request.password,
            &request.role,
        )
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to create operator: {e}"),
        })?;

    // Create audit event for operator lifecycle change
    let actor: Actor = Actor::with_operator(
        operator.operator_id.to_string(),
        String::from("operator"),
        operator.operator_id,
        operator.login_name.clone(),
        operator.display_name.clone(),
    );

    let action: Action = Action::new(
        String::from("CreateOperator"),
        Some(format!(
            "Created operator {} ({}) with role {}",
            request.login_name, request.display_name, request.role
        )),
    );

    let before: StateSnapshot = StateSnapshot::new(String::from("operator_does_not_exist"));
    let after: StateSnapshot = StateSnapshot::new(format!(
        "operator_id={},login_name={},role={}",
        operator_id, request.login_name, request.role
    ));

    // Use placeholder bid_year and area for operator management events
    let placeholder_bid_year: BidYear = BidYear::new(0);
    let placeholder_area: Area = Area::new("_operator_management");

    let audit_event: AuditEvent = AuditEvent::new(
        actor,
        cause,
        action,
        before,
        after,
        placeholder_bid_year,
        placeholder_area,
    );

    // Persist audit event
    persistence
        .persist_audit_event(&audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    Ok(CreateOperatorResponse {
        operator_id,
        login_name: request.login_name,
        display_name: request.display_name,
        role: request.role,
    })
}

/// Lists all operators.
///
/// Only Admin actors may list operators.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `authenticated_actor` - The authenticated actor performing this action
///
/// # Returns
///
/// * `Ok(ListOperatorsResponse)` with the list of operators
/// * `Err(ApiError)` if unauthorized or query fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - Database operations fail
pub fn list_operators(
    persistence: &SqlitePersistence,
    authenticated_actor: &AuthenticatedActor,
) -> Result<ListOperatorsResponse, ApiError> {
    // Enforce authorization before executing command
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("list_operators"),
            required_role: String::from("Admin"),
        });
    }

    let operators: Vec<OperatorData> =
        persistence
            .list_operators()
            .map_err(|e| ApiError::Internal {
                message: format!("Failed to list operators: {e}"),
            })?;

    let operator_infos: Vec<OperatorInfo> = operators
        .into_iter()
        .map(|op| OperatorInfo {
            operator_id: op.operator_id,
            login_name: op.login_name,
            display_name: op.display_name,
            role: op.role,
            is_disabled: op.is_disabled,
            created_at: op.created_at,
            last_login_at: op.last_login_at,
        })
        .collect();

    Ok(ListOperatorsResponse {
        operators: operator_infos,
    })
}

/// Disables an operator.
///
/// Only Admin actors may disable operators.
/// Emits an audit event on success.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The disable operator request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data for audit attribution
/// * `cause` - The cause for this action
///
/// # Returns
///
/// * `Ok(DisableOperatorResponse)` on success
/// * `Err(ApiError)` if unauthorized or operation fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The operator does not exist
/// - Database operations fail
pub fn disable_operator(
    persistence: &mut SqlitePersistence,
    request: DisableOperatorRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<DisableOperatorResponse, ApiError> {
    // Enforce authorization before executing command
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("disable_operator"),
            required_role: String::from("Admin"),
        });
    }

    // Get target operator to verify existence and get details for audit
    let target_operator: OperatorData = persistence
        .get_operator_by_id(request.operator_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to get operator: {e}"),
        })?
        .ok_or_else(|| {
            let operator_id = request.operator_id;
            ApiError::ResourceNotFound {
                resource_type: String::from("Operator"),
                message: format!("Operator with ID {operator_id} not found"),
            }
        })?;

    // Perform the disable operation
    persistence
        .disable_operator(request.operator_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to disable operator: {e}"),
        })?;

    // Create audit event for operator lifecycle change
    let actor: Actor = Actor::with_operator(
        operator.operator_id.to_string(),
        String::from("operator"),
        operator.operator_id,
        operator.login_name.clone(),
        operator.display_name.clone(),
    );

    let action: Action = Action::new(
        String::from("DisableOperator"),
        Some(format!(
            "Disabled operator {} ({})",
            target_operator.login_name, target_operator.display_name
        )),
    );

    let operator_id = request.operator_id;
    let before: StateSnapshot =
        StateSnapshot::new(format!("operator_id={operator_id},is_disabled=false"));
    let after: StateSnapshot =
        StateSnapshot::new(format!("operator_id={operator_id},is_disabled=true"));

    // Use placeholder bid_year and area for operator management events
    let placeholder_bid_year: BidYear = BidYear::new(0);
    let placeholder_area: Area = Area::new("_operator_management");

    let audit_event: AuditEvent = AuditEvent::new(
        actor,
        cause,
        action,
        before,
        after,
        placeholder_bid_year,
        placeholder_area,
    );

    // Persist audit event
    persistence
        .persist_audit_event(&audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    let login_name = &target_operator.login_name;
    Ok(DisableOperatorResponse {
        message: format!("Operator {login_name} has been disabled"),
    })
}

/// Re-enables a disabled operator.
///
/// Only Admin actors may re-enable operators.
/// Emits an audit event on success.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The enable operator request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data for audit attribution
/// * `cause` - The cause for this action
///
/// # Returns
///
/// * `Ok(EnableOperatorResponse)` on success
/// * `Err(ApiError)` if unauthorized or operation fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The operator does not exist
/// - Database operations fail
pub fn enable_operator(
    persistence: &mut SqlitePersistence,
    request: EnableOperatorRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<EnableOperatorResponse, ApiError> {
    // Enforce authorization before executing command
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("enable_operator"),
            required_role: String::from("Admin"),
        });
    }

    // Get target operator to verify existence and get details for audit
    let target_operator: OperatorData = persistence
        .get_operator_by_id(request.operator_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to get operator: {e}"),
        })?
        .ok_or_else(|| {
            let operator_id = request.operator_id;
            ApiError::ResourceNotFound {
                resource_type: String::from("Operator"),
                message: format!("Operator with ID {operator_id} not found"),
            }
        })?;

    // Perform the enable operation
    persistence
        .enable_operator(request.operator_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to enable operator: {e}"),
        })?;

    // Create audit event for operator lifecycle change
    let actor: Actor = Actor::with_operator(
        operator.operator_id.to_string(),
        String::from("operator"),
        operator.operator_id,
        operator.login_name.clone(),
        operator.display_name.clone(),
    );

    let action: Action = Action::new(
        String::from("EnableOperator"),
        Some(format!(
            "Re-enabled operator {} ({})",
            target_operator.login_name, target_operator.display_name
        )),
    );

    let operator_id = request.operator_id;
    let before: StateSnapshot =
        StateSnapshot::new(format!("operator_id={operator_id},is_disabled=true"));
    let after: StateSnapshot =
        StateSnapshot::new(format!("operator_id={operator_id},is_disabled=false"));

    // Use placeholder bid_year and area for operator management events
    let placeholder_bid_year: BidYear = BidYear::new(0);
    let placeholder_area: Area = Area::new("_operator_management");

    let audit_event: AuditEvent = AuditEvent::new(
        actor,
        cause,
        action,
        before,
        after,
        placeholder_bid_year,
        placeholder_area,
    );

    // Persist audit event
    persistence
        .persist_audit_event(&audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    let login_name = &target_operator.login_name;
    Ok(EnableOperatorResponse {
        message: format!("Operator {login_name} has been re-enabled"),
    })
}

/// Deletes an operator.
///
/// Only Admin actors may delete operators.
/// Operators can only be deleted if they are not referenced by any audit events.
/// Emits an audit event on success.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The delete operator request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data for audit attribution
/// * `cause` - The cause for this action
///
/// # Returns
///
/// * `Ok(DeleteOperatorResponse)` on success
/// * `Err(ApiError)` if unauthorized, operator is referenced, or operation fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The operator does not exist
/// - The operator is referenced by audit events
/// - Database operations fail
pub fn delete_operator(
    persistence: &mut SqlitePersistence,
    request: DeleteOperatorRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<DeleteOperatorResponse, ApiError> {
    // Enforce authorization before executing command
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("delete_operator"),
            required_role: String::from("Admin"),
        });
    }

    // Get target operator to verify existence and get details for audit
    let target_operator: OperatorData = persistence
        .get_operator_by_id(request.operator_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to get operator: {e}"),
        })?
        .ok_or_else(|| {
            let operator_id = request.operator_id;
            ApiError::ResourceNotFound {
                resource_type: String::from("Operator"),
                message: format!("Operator with ID {operator_id} not found"),
            }
        })?;

    // Perform the delete operation (will fail if operator is referenced)
    persistence
        .delete_operator(request.operator_id)
        .map_err(|e| match e {
            PersistenceError::OperatorReferenced { operator_id } => ApiError::DomainRuleViolation {
                rule: String::from("operator_not_referenced"),
                message: format!(
                    "Cannot delete operator {operator_id}: referenced by audit events"
                ),
            },
            _ => ApiError::Internal {
                message: format!("Failed to delete operator: {e}"),
            },
        })?;

    // Create audit event for operator lifecycle change
    let actor: Actor = Actor::with_operator(
        operator.operator_id.to_string(),
        String::from("operator"),
        operator.operator_id,
        operator.login_name.clone(),
        operator.display_name.clone(),
    );

    let action: Action = Action::new(
        String::from("DeleteOperator"),
        Some(format!(
            "Deleted operator {} ({})",
            target_operator.login_name, target_operator.display_name
        )),
    );

    let operator_id = request.operator_id;
    let login_name = &target_operator.login_name;
    let before: StateSnapshot =
        StateSnapshot::new(format!("operator_id={operator_id},login_name={login_name}"));
    let after: StateSnapshot = StateSnapshot::new(String::from("operator_deleted"));

    // Use placeholder bid_year and area for operator management events
    let placeholder_bid_year: BidYear = BidYear::new(0);
    let placeholder_area: Area = Area::new("_operator_management");

    let audit_event: AuditEvent = AuditEvent::new(
        actor,
        cause,
        action,
        before,
        after,
        placeholder_bid_year,
        placeholder_area,
    );

    // Persist audit event
    persistence
        .persist_audit_event(&audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    let login_name = &target_operator.login_name;
    Ok(DeleteOperatorResponse {
        message: format!("Operator {login_name} has been deleted"),
    })
}

/// Changes an operator's own password.
///
/// Any authenticated operator may change their own password.
/// Validates the current password, enforces password policy, and invalidates all sessions.
/// Emits an audit event on success.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The change password request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data for audit attribution
/// * `cause` - The cause for this action
///
/// # Returns
///
/// * `Ok(ChangePasswordResponse)` on success
/// * `Err(ApiError)` if validation fails or operation fails
///
/// # Errors
///
/// Returns an error if:
/// - Current password is incorrect
/// - New password does not meet policy requirements
/// - Password confirmation does not match
/// - Database operations fail
pub fn change_password(
    persistence: &mut SqlitePersistence,
    request: &ChangePasswordRequest,
    _authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<ChangePasswordResponse, ApiError> {
    // Verify current password
    let password_valid: bool =
        SqlitePersistence::verify_password(&request.current_password, &operator.password_hash)
            .map_err(|e| ApiError::Internal {
                message: format!("Password verification failed: {e}"),
            })?;

    if !password_valid {
        return Err(ApiError::AuthenticationFailed {
            reason: String::from("Current password is incorrect"),
        });
    }

    // Validate new password policy
    let policy: PasswordPolicy = PasswordPolicy::default();
    policy.validate(
        &request.new_password,
        &request.new_password_confirmation,
        &operator.login_name,
        &operator.display_name,
    )?;

    // Update password
    persistence
        .update_password(operator.operator_id, &request.new_password)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to update password: {e}"),
        })?;

    // Invalidate all sessions for this operator
    persistence
        .delete_sessions_for_operator(operator.operator_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to invalidate sessions: {e}"),
        })?;

    // Create audit event for password change
    let actor: Actor = Actor::with_operator(
        operator.operator_id.to_string(),
        String::from("operator"),
        operator.operator_id,
        operator.login_name.clone(),
        operator.display_name.clone(),
    );

    let action: Action = Action::new(
        String::from("ChangePassword"),
        Some(format!(
            "Operator {} changed their own password",
            operator.login_name
        )),
    );

    let operator_id = operator.operator_id;
    let before: StateSnapshot = StateSnapshot::new(format!("operator_id={operator_id}"));
    let after: StateSnapshot =
        StateSnapshot::new(format!("operator_id={operator_id},password_changed"));

    // Use placeholder bid_year and area for operator management events
    let placeholder_bid_year: BidYear = BidYear::new(0);
    let placeholder_area: Area = Area::new("_operator_management");

    let audit_event: AuditEvent = AuditEvent::new(
        actor,
        cause,
        action,
        before,
        after,
        placeholder_bid_year,
        placeholder_area,
    );

    // Persist audit event
    persistence
        .persist_audit_event(&audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    Ok(ChangePasswordResponse {
        message: String::from("Password changed successfully. All sessions have been invalidated."),
    })
}

/// Resets another operator's password (admin only).
///
/// Only Admin actors may reset other operators' passwords.
/// Does not require the old password, enforces password policy, and invalidates all sessions.
/// Emits an audit event on success.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The reset password request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data for audit attribution (the admin)
/// * `cause` - The cause for this action
///
/// # Returns
///
/// * `Ok(ResetPasswordResponse)` on success
/// * `Err(ApiError)` if unauthorized or operation fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The target operator does not exist
/// - New password does not meet policy requirements
/// - Password confirmation does not match
/// - Database operations fail
pub fn reset_password(
    persistence: &mut SqlitePersistence,
    request: &ResetPasswordRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<ResetPasswordResponse, ApiError> {
    // Enforce authorization before executing command
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("reset_password"),
            required_role: String::from("Admin"),
        });
    }

    // Get target operator to verify existence and get details for validation and audit
    let target_operator: OperatorData = persistence
        .get_operator_by_id(request.operator_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to get operator: {e}"),
        })?
        .ok_or_else(|| {
            let operator_id = request.operator_id;
            ApiError::ResourceNotFound {
                resource_type: String::from("Operator"),
                message: format!("Operator with ID {operator_id} not found"),
            }
        })?;

    // Validate new password policy
    let policy: PasswordPolicy = PasswordPolicy::default();
    policy.validate(
        &request.new_password,
        &request.new_password_confirmation,
        &target_operator.login_name,
        &target_operator.display_name,
    )?;

    // Update password
    persistence
        .update_password(request.operator_id, &request.new_password)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to update password: {e}"),
        })?;

    // Invalidate all sessions for the target operator
    persistence
        .delete_sessions_for_operator(request.operator_id)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to invalidate sessions: {e}"),
        })?;

    // Create audit event for password reset
    let actor: Actor = Actor::with_operator(
        operator.operator_id.to_string(),
        String::from("operator"),
        operator.operator_id,
        operator.login_name.clone(),
        operator.display_name.clone(),
    );

    let action: Action = Action::new(
        String::from("ResetPassword"),
        Some(format!(
            "Admin {} reset password for operator {}",
            operator.login_name, target_operator.login_name
        )),
    );

    let operator_id = request.operator_id;
    let target_login = &target_operator.login_name;
    let before: StateSnapshot = StateSnapshot::new(format!(
        "operator_id={operator_id},login_name={target_login}"
    ));
    let after: StateSnapshot = StateSnapshot::new(format!(
        "operator_id={operator_id},login_name={target_login},password_reset"
    ));

    // Use placeholder bid_year and area for operator management events
    let placeholder_bid_year: BidYear = BidYear::new(0);
    let placeholder_area: Area = Area::new("_operator_management");

    let audit_event: AuditEvent = AuditEvent::new(
        actor,
        cause,
        action,
        before,
        after,
        placeholder_bid_year,
        placeholder_area,
    );

    // Persist audit event
    persistence
        .persist_audit_event(&audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    Ok(ResetPasswordResponse {
        message: format!(
            "Password reset successfully for operator {}. All sessions have been invalidated.",
            target_operator.login_name
        ),
        operator_id: request.operator_id,
    })
}

// ========================================================================
// Bootstrap Authentication (Phase 15)
// ========================================================================

/// Checks whether the system is in bootstrap mode.
///
/// Bootstrap mode is active when no operators exist in the database.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
///
/// # Returns
///
/// * `Ok(BootstrapAuthStatusResponse)` indicating bootstrap status
/// * `Err(ApiError)` if the query fails
///
/// # Errors
///
/// Returns an error if database operations fail.
pub fn check_bootstrap_status(
    persistence: &SqlitePersistence,
) -> Result<crate::BootstrapAuthStatusResponse, ApiError> {
    let operator_count: i64 = persistence
        .count_operators()
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to count operators: {e}"),
        })?;

    Ok(crate::BootstrapAuthStatusResponse {
        is_bootstrap_mode: operator_count == 0,
    })
}

/// Performs bootstrap login with hardcoded credentials.
///
/// This function only succeeds when:
/// - No operators exist in the database (bootstrap mode)
/// - Username is exactly "admin"
/// - Password is exactly "admin"
///
/// The returned token is a temporary bootstrap session, not a real operator session.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The bootstrap login request
///
/// # Returns
///
/// * `Ok(BootstrapLoginResponse)` with a bootstrap token
/// * `Err(ApiError)` if bootstrap mode is not active or credentials are invalid
///
/// # Errors
///
/// Returns an error if:
/// - Operators already exist (not in bootstrap mode)
/// - Credentials are not exactly "admin" / "admin"
/// - Database operations fail
///
/// # Panics
///
/// Panics if the system time is before the Unix epoch.
pub fn bootstrap_login(
    persistence: &SqlitePersistence,
    request: &crate::BootstrapLoginRequest,
) -> Result<crate::BootstrapLoginResponse, ApiError> {
    // Check if we're in bootstrap mode
    let operator_count: i64 = persistence
        .count_operators()
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to count operators: {e}"),
        })?;

    if operator_count > 0 {
        return Err(ApiError::Unauthorized {
            action: String::from("bootstrap_login"),
            required_role: String::from("Bootstrap mode (no operators exist)"),
        });
    }

    // Verify hardcoded credentials
    if request.username != "admin" || request.password != "admin" {
        return Err(ApiError::from(AuthError::AuthenticationFailed {
            reason: String::from("Invalid bootstrap credentials"),
        }));
    }

    // Generate a bootstrap token (simple, temporary)
    let timestamp: u128 = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_nanos();
    let bootstrap_token: String = format!("bootstrap_{timestamp}_{}", rand::random::<u64>());

    Ok(crate::BootstrapLoginResponse {
        bootstrap_token,
        is_bootstrap: true,
    })
}

/// Creates the first admin operator during bootstrap.
///
/// This function only succeeds when:
/// - No operators exist in the database (bootstrap mode)
/// - A valid bootstrap token is provided
///
/// After successful creation, the bootstrap session is terminated and
/// the system transitions out of bootstrap mode.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The create first admin request
///
/// # Returns
///
/// * `Ok(CreateFirstAdminResponse)` on success
/// * `Err(ApiError)` if not in bootstrap mode or creation fails
///
/// # Errors
///
/// Returns an error if:
/// - Operators already exist (not in bootstrap mode)
/// - Login name already exists
/// - Password validation fails
/// - Database operations fail
pub fn create_first_admin(
    persistence: &mut SqlitePersistence,
    request: crate::CreateFirstAdminRequest,
) -> Result<crate::CreateFirstAdminResponse, ApiError> {
    // Check if we're in bootstrap mode
    let operator_count: i64 = persistence
        .count_operators()
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to count operators: {e}"),
        })?;

    if operator_count > 0 {
        return Err(ApiError::Unauthorized {
            action: String::from("create_first_admin"),
            required_role: String::from("Bootstrap mode (no operators exist)"),
        });
    }

    // Validate password policy
    let policy: PasswordPolicy = PasswordPolicy::default();
    policy.validate(
        &request.password,
        &request.password_confirmation,
        &request.login_name,
        &request.display_name,
    )?;

    // Create the first admin operator
    let operator_id: i64 = persistence
        .create_operator(
            &request.login_name,
            &request.display_name,
            &request.password,
            "Admin",
        )
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to create first admin: {e}"),
        })?;

    Ok(crate::CreateFirstAdminResponse {
        operator_id,
        login_name: request.login_name,
        display_name: request.display_name,
        message: String::from("First admin operator created successfully"),
    })
}

// ========================================================================
// Phase 18: Bootstrap Workflow Completion Handlers
// ========================================================================

/// Sets the active bid year.
#[allow(dead_code)]
///
/// Only admins can set the active bid year.
/// Exactly one bid year may be active at a time.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `metadata` - The current bootstrap metadata
/// * `request` - The set active bid year request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data
/// * `cause` - The cause or reason for this action
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The bid year does not exist
/// - Database operations fail
pub fn set_active_bid_year(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
    request: &SetActiveBidYearRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<SetActiveBidYearResponse, ApiError> {
    // Enforce authorization - only admins can set active bid year
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("set_active_bid_year"),
            required_role: String::from("Admin"),
        });
    }

    // Apply the command
    let command = Command::SetActiveBidYear { year: request.year };
    let actor: Actor = authenticated_actor.to_audit_actor(operator);
    let result: BootstrapResult =
        apply_bootstrap(metadata, command, actor, cause).map_err(translate_core_error)?;

    // Persist the active bid year setting
    persistence
        .set_active_bid_year(request.year)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to set active bid year: {e}"),
        })?;

    // Persist audit event
    persistence
        .persist_audit_event(&result.audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    Ok(SetActiveBidYearResponse {
        year: request.year,
        message: format!("Bid year {} is now active", request.year),
    })
}

/// Gets the currently active bid year.
#[allow(dead_code)]
///
/// # Arguments
///
/// * `persistence` - The persistence layer
///
/// # Errors
///
/// Returns an error if database operations fail.
pub fn get_active_bid_year(
    persistence: &SqlitePersistence,
) -> Result<GetActiveBidYearResponse, ApiError> {
    let year: Option<u16> = persistence
        .get_active_bid_year()
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to get active bid year: {e}"),
        })?;

    Ok(GetActiveBidYearResponse { year })
}

/// Sets the expected area count for a bid year.
#[allow(dead_code)]
///
/// Only admins can set expected area counts.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `metadata` - The current bootstrap metadata
/// * `request` - The set expected area count request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data
/// * `cause` - The cause or reason for this action
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The bid year does not exist
/// - The expected count is zero
/// - Database operations fail
pub fn set_expected_area_count(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
    request: &SetExpectedAreaCountRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<SetExpectedAreaCountResponse, ApiError> {
    // Enforce authorization - only admins can set expected counts
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("set_expected_area_count"),
            required_role: String::from("Admin"),
        });
    }

    let bid_year = BidYear::new(request.bid_year);
    let command = Command::SetExpectedAreaCount {
        bid_year,
        expected_count: request.expected_count,
    };

    let actor: Actor = authenticated_actor.to_audit_actor(operator);
    let result: BootstrapResult =
        apply_bootstrap(metadata, command, actor, cause).map_err(translate_core_error)?;

    // Persist the expected area count
    persistence
        .set_expected_area_count(request.bid_year, request.expected_count)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to set expected area count: {e}"),
        })?;

    // Persist audit event
    persistence
        .persist_audit_event(&result.audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    Ok(SetExpectedAreaCountResponse {
        bid_year: request.bid_year,
        expected_count: request.expected_count,
        message: format!(
            "Expected area count set to {} for bid year {}",
            request.expected_count, request.bid_year
        ),
    })
}

/// Sets the expected user count for an area.
#[allow(dead_code)]
///
/// Only admins can set expected user counts.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `metadata` - The current bootstrap metadata
/// * `request` - The set expected user count request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data
/// * `cause` - The cause or reason for this action
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The bid year or area does not exist
/// - The expected count is zero
/// - Database operations fail
pub fn set_expected_user_count(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
    request: &SetExpectedUserCountRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<SetExpectedUserCountResponse, ApiError> {
    // Enforce authorization - only admins can set expected counts
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("set_expected_user_count"),
            required_role: String::from("Admin"),
        });
    }

    let bid_year = BidYear::new(request.bid_year);
    let area = Area::new(&request.area);
    let command = Command::SetExpectedUserCount {
        bid_year,
        area,
        expected_count: request.expected_count,
    };

    let actor: Actor = authenticated_actor.to_audit_actor(operator);
    let result: BootstrapResult =
        apply_bootstrap(metadata, command, actor, cause).map_err(translate_core_error)?;

    // Persist the expected user count
    let area_ref = Area::new(&request.area);
    persistence
        .set_expected_user_count(
            &BidYear::new(request.bid_year),
            &area_ref,
            request.expected_count,
        )
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to set expected user count: {e}"),
        })?;

    // Persist audit event
    persistence
        .persist_audit_event(&result.audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    Ok(SetExpectedUserCountResponse {
        bid_year: request.bid_year,
        area: request.area.clone(),
        expected_count: request.expected_count,
        message: format!(
            "Expected user count set to {} for area '{}' in bid year {}",
            request.expected_count, request.area, request.bid_year
        ),
    })
}

/// Updates an existing user's information.
#[allow(dead_code)]
///
/// Only admins can update users.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `metadata` - The current bootstrap metadata
/// * `state` - The current system state
/// * `request` - The update user request
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `operator` - The operator data
/// * `cause` - The cause or reason for this action
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The user does not exist
/// - Validation fails
/// - Database operations fail
pub fn update_user(
    persistence: &mut SqlitePersistence,
    metadata: &BootstrapMetadata,
    state: &State,
    request: &UpdateUserRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<ApiResult<UpdateUserResponse>, ApiError> {
    // Enforce authorization - only admins can update users
    AuthorizationService::authorize_register_user(authenticated_actor)?;

    // Translate API request into domain types
    let bid_year: BidYear = BidYear::new(request.bid_year);
    let initials: Initials = Initials::new(&request.initials);
    let area: Area = Area::new(&request.area);
    let user_type: UserType =
        UserType::parse(&request.user_type).map_err(translate_domain_error)?;
    let crew: Option<Crew> = match request.crew {
        Some(crew_num) => Some(Crew::new(crew_num).map_err(translate_domain_error)?),
        None => None,
    };
    let seniority_data: SeniorityData = SeniorityData::new(
        request.cumulative_natca_bu_date.clone(),
        request.natca_bu_date.clone(),
        request.eod_faa_date.clone(),
        request.service_computation_date.clone(),
        request.lottery_value,
    );

    // Create command
    let command = Command::UpdateUser {
        bid_year: bid_year.clone(),
        initials: initials.clone(),
        name: request.name.clone(),
        area: area.clone(),
        user_type,
        crew,
        seniority_data,
    };

    // Convert authenticated actor to audit actor
    let actor: Actor = authenticated_actor.to_audit_actor(operator);

    // Apply the command
    let result: TransitionResult =
        apply(metadata, state, command, actor, cause).map_err(translate_core_error)?;

    // Persist the updated canonical user state
    persistence
        .update_user(
            &bid_year,
            &initials,
            &request.name,
            &area,
            &request.user_type,
            request.crew,
            &request.cumulative_natca_bu_date,
            &request.natca_bu_date,
            &request.eod_faa_date,
            &request.service_computation_date,
            request.lottery_value,
        )
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to update user: {e}"),
        })?;

    // Persist audit event
    persistence
        .persist_audit_event(&result.audit_event)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to persist audit event: {e}"),
        })?;

    // Build response
    let response = UpdateUserResponse {
        bid_year: request.bid_year,
        initials: request.initials.clone(),
        name: request.name.clone(),
        message: String::from("User updated successfully"),
    };

    Ok(ApiResult {
        response,
        audit_event: result.audit_event,
        new_state: result.new_state,
    })
}

/// Gets the bootstrap completeness status for all bid years and areas.
#[allow(dead_code)]
///
/// This function computes whether each bid year and area meets its
/// expected counts and returns detailed blocking reasons.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `metadata` - The current bootstrap metadata
///
/// # Errors
///
/// Returns an error if database operations fail.
#[allow(clippy::too_many_lines)]
pub fn get_bootstrap_completeness(
    persistence: &SqlitePersistence,
    metadata: &BootstrapMetadata,
) -> Result<GetBootstrapCompletenessResponse, ApiError> {
    let active_bid_year: Option<u16> =
        persistence
            .get_active_bid_year()
            .map_err(|e| ApiError::Internal {
                message: format!("Failed to get active bid year: {e}"),
            })?;

    let mut bid_years_info: Vec<BidYearCompletenessInfo> = Vec::new();
    let mut areas_info: Vec<AreaCompletenessInfo> = Vec::new();
    let mut top_level_blocking: Vec<BlockingReason> = Vec::new();

    // If no active bid year, that's a top-level blocker
    if active_bid_year.is_none() {
        top_level_blocking.push(BlockingReason::NoActiveBidYear);
    }

    // Check each bid year
    for bid_year in &metadata.bid_years {
        let year: u16 = bid_year.year();
        let is_active: bool = active_bid_year == Some(year);

        let expected_area_count: Option<u32> =
            persistence
                .get_expected_area_count(year)
                .map_err(|e| ApiError::Internal {
                    message: format!("Failed to get expected area count: {e}"),
                })?;

        let actual_area_count: usize =
            persistence
                .get_actual_area_count(year)
                .map_err(|e| ApiError::Internal {
                    message: format!("Failed to get actual area count: {e}"),
                })?;

        let mut blocking_reasons: Vec<BlockingReason> = Vec::new();

        // Check if expected count is set
        let expected_count = expected_area_count.unwrap_or_else(|| {
            blocking_reasons.push(BlockingReason::ExpectedAreaCountNotSet { bid_year: year });
            0 // Placeholder
        });

        // Check if actual matches expected
        if expected_area_count.is_some() && actual_area_count != expected_count as usize {
            blocking_reasons.push(BlockingReason::AreaCountMismatch {
                bid_year: year,
                expected: expected_count,
                actual: actual_area_count,
            });
        }

        let is_complete: bool = blocking_reasons.is_empty() && expected_area_count.is_some();

        bid_years_info.push(BidYearCompletenessInfo {
            year,
            is_active,
            expected_area_count,
            actual_area_count,
            is_complete,
            blocking_reasons,
        });
    }

    // Check each area
    for (bid_year, area) in &metadata.areas {
        let year: u16 = bid_year.year();

        let expected_user_count: Option<u32> = persistence
            .get_expected_user_count(bid_year, area)
            .map_err(|e| ApiError::Internal {
                message: format!("Failed to get expected user count: {e}"),
            })?;

        let actual_user_count: usize =
            persistence
                .get_actual_user_count(bid_year, area)
                .map_err(|e| ApiError::Internal {
                    message: format!("Failed to get actual user count: {e}"),
                })?;

        let mut blocking_reasons: Vec<BlockingReason> = Vec::new();

        // Check if expected count is set
        let expected_count = expected_user_count.unwrap_or_else(|| {
            blocking_reasons.push(BlockingReason::ExpectedUserCountNotSet {
                bid_year: year,
                area: area.id().to_string(),
            });
            0 // Placeholder
        });

        // Check if actual matches expected
        if expected_user_count.is_some() && actual_user_count != expected_count as usize {
            blocking_reasons.push(BlockingReason::UserCountMismatch {
                bid_year: year,
                area: area.id().to_string(),
                expected: expected_count,
                actual: actual_user_count,
            });
        }

        let is_complete: bool = blocking_reasons.is_empty() && expected_user_count.is_some();

        areas_info.push(AreaCompletenessInfo {
            bid_year: year,
            area: area.id().to_string(),
            expected_user_count,
            actual_user_count,
            is_complete,
            blocking_reasons,
        });
    }

    // Determine if system is ready for bidding
    let is_ready_for_bidding: bool = active_bid_year.is_some()
        && bid_years_info.iter().all(|b| b.is_complete)
        && areas_info.iter().all(|a| a.is_complete);

    Ok(GetBootstrapCompletenessResponse {
        active_bid_year,
        bid_years: bid_years_info,
        areas: areas_info,
        is_ready_for_bidding,
        blocking_reasons: top_level_blocking,
    })
}

/// Previews and validates CSV user data without persisting.
///
/// This handler:
/// - Accepts CSV content and a bid year
/// - Parses and validates each row
/// - Returns structured preview results
/// - Does NOT mutate state or emit audit events
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `persistence` - The persistence layer for querying existing users
/// * `request` - The preview request containing bid year and CSV content
/// * `authenticated_actor` - The authenticated actor making the request
///
/// # Returns
///
/// * `Ok(PreviewCsvUsersResponse)` with per-row validation results
/// * `Err(ApiError)` if unauthorized or CSV format is invalid
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not an admin
/// - The bid year does not exist
/// - The CSV format is invalid
pub fn preview_csv_users(
    metadata: &BootstrapMetadata,
    persistence: &SqlitePersistence,
    request: &PreviewCsvUsersRequest,
    authenticated_actor: &AuthenticatedActor,
) -> Result<PreviewCsvUsersResponse, ApiError> {
    // Enforce authorization - only admins can preview CSV imports
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("preview_csv_users"),
            required_role: String::from("Admin"),
        });
    }

    // Validate bid year exists
    let bid_year: BidYear = BidYear::new(request.bid_year);
    validate_bid_year_exists(metadata, &bid_year).map_err(translate_domain_error)?;

    // Perform CSV preview validation
    let preview_result =
        preview_csv_users_impl(&request.csv_content, &bid_year, metadata, persistence)?;

    // Convert internal result to API response
    let rows: Vec<CsvRowPreview> = preview_result
        .rows
        .into_iter()
        .map(|r: CsvRowResult| CsvRowPreview {
            row_number: r.row_number,
            initials: r.initials,
            name: r.name,
            area_id: r.area_id,
            user_type: r.user_type,
            crew: r.crew,
            status: match r.status {
                crate::csv_preview::CsvRowStatus::Valid => CsvRowStatus::Valid,
                crate::csv_preview::CsvRowStatus::Invalid => CsvRowStatus::Invalid,
            },
            errors: r.errors,
        })
        .collect();

    Ok(PreviewCsvUsersResponse {
        bid_year: request.bid_year,
        rows,
        total_rows: preview_result.total_rows,
        valid_count: preview_result.valid_count,
        invalid_count: preview_result.invalid_count,
    })
}
