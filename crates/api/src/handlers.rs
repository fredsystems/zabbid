// Copyright (C) 2026 Fred Clausen
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

//! API handler functions for state-changing and read-only operations.

use std::time::{SystemTime, UNIX_EPOCH};
use zab_bid::{
    BootstrapMetadata, BootstrapResult, Command, State, TransitionResult, apply, apply_bootstrap,
    validate_area_exists, validate_bid_year_exists,
};
use zab_bid_audit::{Actor, AuditEvent, Cause};
use zab_bid_domain::{
    Area, BidYear, CanonicalBidYear, Crew, Initials, LeaveAccrualResult, LeaveAvailabilityResult,
    LeaveUsage, SeniorityData, UserType, calculate_leave_accrual, calculate_leave_availability,
};
use zab_bid_persistence::{OperatorData, SqlitePersistence};

use crate::auth::{AuthenticatedActor, AuthenticationService, AuthorizationService, Role};
use crate::error::{ApiError, AuthError, translate_core_error, translate_domain_error};
use crate::request_response::{
    BidYearInfo, CreateAreaRequest, CreateBidYearRequest, CreateOperatorRequest,
    CreateOperatorResponse, GetLeaveAvailabilityResponse, ListAreasRequest, ListAreasResponse,
    ListBidYearsResponse, ListOperatorsResponse, ListUsersResponse, LoginRequest, LoginResponse,
    OperatorInfo, RegisterUserRequest, RegisterUserResponse, UserInfo, WhoAmIResponse,
};

/// The result of an API operation that includes both the response and the audit event.
///
/// This ensures that successful API operations always produce an audit trail.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ApiResult<T> {
    /// The API response.
    pub response: T,
    /// The audit event generated by this operation.
    pub audit_event: AuditEvent,
    /// The new state after the operation.
    pub new_state: State,
}

/// Registers a new user via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Translates the API request into a core command
/// - Applies the command to the current state
/// - Translates any errors to API errors
/// - Returns the API response with audit event on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `state` - The current system state
/// * `request` - The API request to register a user
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(ApiResult<RegisterUserResponse>)` on success
/// * `Err(ApiError)` if unauthorized, the request is invalid, or a domain rule is violated
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - Any field validation fails
/// - The initials are already in use within the bid year
pub fn register_user(
    metadata: &BootstrapMetadata,
    state: &State,
    request: RegisterUserRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<ApiResult<RegisterUserResponse>, ApiError> {
    // Enforce authorization before executing command
    AuthorizationService::authorize_register_user(authenticated_actor)?;

    // Convert authenticated actor to audit actor with operator information
    let actor: Actor = authenticated_actor.to_audit_actor(operator);
    // Translate API request into domain types
    let bid_year: BidYear = BidYear::new(request.bid_year);
    let initials: Initials = Initials::new(&request.initials);
    let area: Area = Area::new(&request.area);

    // Parse user type
    let user_type: UserType =
        UserType::parse(&request.user_type).map_err(translate_domain_error)?;

    // Parse optional crew
    let crew: Option<Crew> = match request.crew {
        Some(crew_num) => Some(Crew::new(crew_num).map_err(translate_domain_error)?),
        None => None,
    };

    let seniority_data: SeniorityData = SeniorityData::new(
        request.cumulative_natca_bu_date,
        request.natca_bu_date,
        request.eod_faa_date,
        request.service_computation_date,
        request.lottery_value,
    );

    // Create core command
    let command: Command = Command::RegisterUser {
        bid_year: bid_year.clone(),
        initials: initials.clone(),
        name: request.name.clone(),
        area,
        user_type,
        crew,
        seniority_data,
    };

    // Apply command via core transition
    let transition_result: TransitionResult =
        apply(metadata, state, command, actor, cause).map_err(translate_core_error)?;

    // Translate to API response
    let response: RegisterUserResponse = RegisterUserResponse {
        bid_year: bid_year.year(),
        initials: initials.value().to_string(),
        name: request.name,
        message: format!(
            "Successfully registered user '{}' for bid year {}",
            initials.value(),
            bid_year.year()
        ),
    };

    Ok(ApiResult {
        response,
        audit_event: transition_result.audit_event,
        new_state: transition_result.new_state,
    })
}

/// Creates a checkpoint via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a checkpoint command
/// - Applies the command to the current state
/// - Returns the transition result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `state` - The current system state
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(TransitionResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The command execution fails
pub fn checkpoint(
    metadata: &BootstrapMetadata,
    state: &State,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<TransitionResult, ApiError> {
    // Enforce authorization before executing command
    AuthorizationService::authorize_checkpoint(authenticated_actor)?;

    // Convert authenticated actor to audit actor with operator information
    let actor: Actor = authenticated_actor.to_audit_actor(operator);

    // Create and apply checkpoint command
    let command: Command = Command::Checkpoint;
    let transition_result: TransitionResult =
        apply(metadata, state, command, actor, cause).map_err(translate_core_error)?;

    Ok(transition_result)
}

/// Finalizes a round via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a finalize command
/// - Applies the command to the current state
/// - Returns the transition result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `state` - The current system state
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(TransitionResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The command execution fails
pub fn finalize(
    metadata: &BootstrapMetadata,
    state: &State,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<TransitionResult, ApiError> {
    // Enforce authorization before executing command
    AuthorizationService::authorize_finalize(authenticated_actor)?;

    // Convert authenticated actor to audit actor with operator information
    let actor: Actor = authenticated_actor.to_audit_actor(operator);

    // Create and apply finalize command
    let command: Command = Command::Finalize;
    let transition_result: TransitionResult =
        apply(metadata, state, command, actor, cause).map_err(translate_core_error)?;

    Ok(transition_result)
}

/// Rolls back to a specific event via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a rollback command
/// - Applies the command to the current state
/// - Returns the transition result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `state` - The current system state
/// * `target_event_id` - The event ID to rollback to
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(TransitionResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The command execution fails
pub fn rollback(
    metadata: &BootstrapMetadata,
    state: &State,
    target_event_id: i64,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<TransitionResult, ApiError> {
    // Enforce authorization before executing command
    AuthorizationService::authorize_rollback(authenticated_actor)?;

    // Convert authenticated actor to audit actor with operator information
    let actor: Actor = authenticated_actor.to_audit_actor(operator);

    // Create and apply rollback command
    let command: Command = Command::RollbackToEventId { target_event_id };
    let transition_result: TransitionResult =
        apply(metadata, state, command, actor, cause).map_err(translate_core_error)?;

    Ok(transition_result)
}

/// Creates a new bid year via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a `CreateBidYear` command
/// - Applies the command to the bootstrap metadata
/// - Returns the bootstrap result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `request` - The API request to create a bid year
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(BootstrapResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The bid year already exists
/// - The bid year value is invalid
pub fn create_bid_year(
    metadata: &BootstrapMetadata,
    request: &CreateBidYearRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<BootstrapResult, ApiError> {
    // Enforce authorization - only admins can create bid years
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("create_bid_year"),
            required_role: String::from("Admin"),
        });
    }

    // Convert authenticated actor to audit actor with operator information
    let actor: Actor = authenticated_actor.to_audit_actor(operator);

    // Create command with canonical metadata
    let command: Command = Command::CreateBidYear {
        year: request.year,
        start_date: request.start_date,
        num_pay_periods: request.num_pay_periods,
    };

    // Apply command via core bootstrap
    let bootstrap_result: BootstrapResult =
        apply_bootstrap(metadata, command, actor, cause).map_err(translate_core_error)?;

    Ok(bootstrap_result)
}

/// Creates a new area via the API boundary with authorization.
///
/// This function:
/// - Verifies the actor is authorized (Admin role required)
/// - Creates a `CreateArea` command
/// - Applies the command to the bootstrap metadata
/// - Returns the bootstrap result on success
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `request` - The API request to create an area
/// * `authenticated_actor` - The authenticated actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(BootstrapResult)` on success
/// * `Err(ApiError)` if unauthorized or the command fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The bid year does not exist
/// - The area already exists in the bid year
pub fn create_area(
    metadata: &BootstrapMetadata,
    request: &CreateAreaRequest,
    authenticated_actor: &AuthenticatedActor,
    operator: &OperatorData,
    cause: Cause,
) -> Result<BootstrapResult, ApiError> {
    // Enforce authorization - only admins can create areas
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("create_area"),
            required_role: String::from("Admin"),
        });
    }

    // Convert authenticated actor to audit actor with operator information
    let actor: Actor = authenticated_actor.to_audit_actor(operator);

    // Create command
    let command: Command = Command::CreateArea {
        bid_year: BidYear::new(request.bid_year),
        area_id: request.area_id.clone(),
    };

    // Apply command via core bootstrap
    let bootstrap_result: BootstrapResult =
        apply_bootstrap(metadata, command, actor, cause).map_err(translate_core_error)?;

    Ok(bootstrap_result)
}

/// Lists all bid years with their canonical metadata.
///
/// This operation never fails and requires no authorization.
/// Returns an empty list if no bid years have been created.
///
/// # Arguments
///
/// * `canonical_bid_years` - The list of canonical bid years from persistence
///
/// # Returns
///
/// A response containing all bid years with canonical metadata.
///
/// # Errors
///
/// Returns an error if end date derivation fails due to date arithmetic overflow.
pub fn list_bid_years(
    canonical_bid_years: &[CanonicalBidYear],
) -> Result<ListBidYearsResponse, ApiError> {
    let bid_years: Result<Vec<BidYearInfo>, ApiError> = canonical_bid_years
        .iter()
        .map(|c| {
            let end_date: time::Date = c.end_date().map_err(translate_domain_error)?;
            Ok(BidYearInfo {
                year: c.year(),
                start_date: c.start_date(),
                num_pay_periods: c.num_pay_periods(),
                end_date,
                area_count: 0,       // Will be populated by server layer
                total_user_count: 0, // Will be populated by server layer
            })
        })
        .collect();

    Ok(ListBidYearsResponse {
        bid_years: bid_years?,
    })
}

/// Lists all areas for a given bid year.
///
/// This is a read-only operation that requires no authorization.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `request` - The list areas request
///
/// # Returns
///
/// * `Ok(ListAreasResponse)` containing all areas for the bid year
/// * `Err(ApiError)` if the bid year does not exist
///
/// # Errors
///
/// Returns an error if the bid year has not been created.
pub fn list_areas(
    metadata: &BootstrapMetadata,
    request: &ListAreasRequest,
) -> Result<ListAreasResponse, ApiError> {
    let bid_year: BidYear = BidYear::new(request.bid_year);

    // Validate bid year exists before querying
    validate_bid_year_exists(metadata, &bid_year).map_err(translate_domain_error)?;

    let areas: Vec<crate::request_response::AreaInfo> = metadata
        .areas
        .iter()
        .filter(|(by, _)| by.year() == bid_year.year())
        .map(|(_, area)| crate::request_response::AreaInfo {
            area_id: area.id().to_string(),
            user_count: 0, // Will be populated by server layer with actual counts
        })
        .collect();

    Ok(ListAreasResponse {
        bid_year: request.bid_year,
        areas,
    })
}

/// Lists all users for a given bid year and area.
///
/// This is a read-only operation that requires no authorization.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `bid_year` - The bid year to list users for
/// * `area` - The area to list users for
/// * `state` - The current state for the bid year and area
///
/// # Returns
///
/// * `Ok(ListUsersResponse)` containing all users for the scope
/// * `Err(ApiError)` if the bid year or area does not exist
///
/// # Errors
///
/// Returns an error if:
/// - The bid year has not been created
/// - The area has not been created in the bid year
pub fn list_users(
    metadata: &BootstrapMetadata,
    canonical_bid_years: &[CanonicalBidYear],
    bid_year: &BidYear,
    area: &Area,
    state: &State,
) -> Result<ListUsersResponse, ApiError> {
    // Validate bid year and area exist before processing
    validate_area_exists(metadata, bid_year, area).map_err(translate_domain_error)?;

    // Find the canonical bid year metadata for leave calculations
    let canonical_bid_year: &CanonicalBidYear = canonical_bid_years
        .iter()
        .find(|c| c.year() == bid_year.year())
        .ok_or_else(|| {
            translate_domain_error(zab_bid_domain::DomainError::InvalidBidYear(format!(
                "Bid year {} not found",
                bid_year.year()
            )))
        })?;

    let users: Vec<UserInfo> = state
        .users
        .iter()
        .map(|user| {
            // Calculate leave accrual for this user
            let leave_accrual_result: LeaveAccrualResult =
                calculate_leave_accrual(user, canonical_bid_year).unwrap_or_else(|_| {
                    LeaveAccrualResult {
                        total_hours: 0,
                        total_days: 0,
                        rounded_up: false,
                        breakdown: vec![],
                    }
                });

            let earned_hours: u16 = leave_accrual_result.total_hours;
            let earned_days: u16 = leave_accrual_result.total_days;

            // Calculate availability
            // For Phase 11, we don't have bid records yet, so usage is empty
            let availability: LeaveAvailabilityResult =
                calculate_leave_availability(&leave_accrual_result, std::iter::empty())
                    .unwrap_or_else(|_| LeaveAvailabilityResult {
                        earned_hours,
                        earned_days,
                        used_hours: 0,
                        remaining_hours: i32::from(earned_hours),
                        remaining_days: i32::from(earned_days),
                        is_exhausted: false,
                        is_overdrawn: false,
                    });

            UserInfo {
                initials: user.initials.value().to_string(),
                name: user.name.clone(),
                crew: user.crew.as_ref().map(Crew::number),
                user_type: user.user_type.as_str().to_string(),
                earned_hours,
                earned_days,
                remaining_hours: availability.remaining_hours,
                remaining_days: availability.remaining_days,
                is_exhausted: availability.is_exhausted,
                is_overdrawn: availability.is_overdrawn,
            }
        })
        .collect();

    Ok(ListUsersResponse {
        bid_year: state.bid_year.year(),
        area: state.area.id().to_string(),
        users,
    })
}

/// Gets the current state for a given bid year and area.
///
/// This is a read-only operation that requires no authorization.
/// This function validates that the bid year and area exist before
/// attempting to load state from persistence.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `bid_year` - The bid year to get state for
/// * `area` - The area to get state for
/// * `state` - The current state (if it exists)
///
/// # Returns
///
/// * `Ok(State)` - The current state for the scope
/// * `Err(ApiError)` if the bid year or area does not exist
///
/// # Errors
///
/// Returns an error if:
/// - The bid year has not been created
/// - The area has not been created in the bid year
pub fn get_current_state(
    metadata: &BootstrapMetadata,
    bid_year: &BidYear,
    area: &Area,
    state: State,
) -> Result<State, ApiError> {
    // Validate bid year and area exist before returning state
    validate_area_exists(metadata, bid_year, area).map_err(translate_domain_error)?;

    Ok(state)
}

/// Gets the historical state for a given bid year and area at a specific timestamp.
///
/// This is a read-only operation that requires no authorization.
/// This function validates that the bid year and area exist before
/// attempting to load historical state from persistence.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `bid_year` - The bid year to get state for
/// * `area` - The area to get state for
/// * `state` - The historical state (if it exists)
///
/// # Returns
///
/// * `Ok(State)` - The historical state for the scope at the timestamp
/// * `Err(ApiError)` if the bid year or area does not exist
///
/// # Errors
///
/// Returns an error if:
/// - The bid year has not been created
/// - The area has not been created in the bid year
pub fn get_historical_state(
    metadata: &BootstrapMetadata,
    bid_year: &BidYear,
    area: &Area,
    state: State,
) -> Result<State, ApiError> {
    // Validate bid year and area exist before returning state
    validate_area_exists(metadata, bid_year, area).map_err(translate_domain_error)?;

    Ok(state)
}

/// Gets leave availability for a specific user.
///
/// This is a read-only operation that:
/// - Validates the bid year and area exist
/// - Finds the specified user
/// - Calculates leave accrual using Phase 9 logic
/// - Retrieves leave usage records (currently none exist in persistence)
/// - Calculates remaining leave availability
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `canonical_bid_year` - The canonical bid year for accrual calculation
/// * `area` - The area
/// * `initials` - The user's initials
/// * `state` - The current state
///
/// # Returns
///
/// * `Ok(GetLeaveAvailabilityResponse)` - The leave availability information
/// * `Err(ApiError)` if the bid year, area, or user does not exist
///
/// # Errors
///
/// Returns an error if:
/// - The bid year does not exist
/// - The area does not exist in the bid year
/// - The user does not exist in the area
/// - Leave accrual calculation fails
/// - Leave availability calculation fails
pub fn get_leave_availability(
    metadata: &BootstrapMetadata,
    canonical_bid_year: &CanonicalBidYear,
    area: &Area,
    initials: &Initials,
    state: &State,
) -> Result<GetLeaveAvailabilityResponse, ApiError> {
    let bid_year: BidYear = BidYear::new(canonical_bid_year.year());

    // Validate bid year and area exist
    validate_area_exists(metadata, &bid_year, area).map_err(translate_domain_error)?;

    // Find the user
    let user = state
        .users
        .iter()
        .find(|u| u.initials == *initials)
        .ok_or_else(|| ApiError::ResourceNotFound {
            resource_type: String::from("User"),
            message: format!(
                "User with initials '{}' not found in bid year {} area {}",
                initials.value(),
                bid_year.year(),
                area.id()
            ),
        })?;

    // Calculate leave accrual using Phase 9
    let accrual =
        calculate_leave_accrual(user, canonical_bid_year).map_err(translate_domain_error)?;

    // Retrieve leave usage records
    // Note: For Phase 10, no persistence for leave usage exists yet.
    // We pass an empty iterator, which means all earned leave is available.
    let usage_records: Vec<LeaveUsage> = Vec::new();

    // Calculate leave availability
    let availability: LeaveAvailabilityResult =
        calculate_leave_availability(&accrual, usage_records).map_err(translate_domain_error)?;

    // Build explanation
    let explanation: String = format!(
        "Leave accrual calculated for user '{}' in bid year {}. \
         Earned: {} hours ({} days). Used: {} hours. \
         Remaining: {} hours ({} days).{}{}",
        initials.value(),
        bid_year.year(),
        availability.earned_hours,
        availability.earned_days,
        availability.used_hours,
        availability.remaining_hours,
        availability.remaining_days,
        if availability.is_exhausted {
            " Leave fully exhausted."
        } else {
            ""
        },
        if availability.is_overdrawn {
            " Leave balance is overdrawn."
        } else {
            ""
        }
    );

    Ok(GetLeaveAvailabilityResponse {
        bid_year: bid_year.year(),
        initials: initials.value().to_string(),
        earned_hours: availability.earned_hours,
        earned_days: availability.earned_days,
        used_hours: availability.used_hours,
        remaining_hours: availability.remaining_hours,
        remaining_days: availability.remaining_days,
        is_exhausted: availability.is_exhausted,
        is_overdrawn: availability.is_overdrawn,
        explanation,
    })
}

/// Gets a comprehensive bootstrap status summary.
///
/// This is a read-only operation that provides aggregated information
/// about all bid years and areas in the system.
///
/// # Arguments
///
/// * `metadata` - The current bootstrap metadata
/// * `area_counts` - Area counts per bid year
/// * `user_counts_by_year` - Total user counts per bid year
/// * `user_counts_by_area` - User counts per (`bid_year`, `area_id`)
///
/// # Returns
///
/// * `Ok(BootstrapStatusResponse)` containing all system status information
///
/// # Errors
///
/// This function does not currently return errors, but the return type supports
/// future error conditions.
///
/// This endpoint is useful for operators to get a complete picture of the
/// system state in a single API call.
pub fn get_bootstrap_status(
    metadata: &BootstrapMetadata,
    area_counts: &[(u16, usize)],
    user_counts_by_year: &[(u16, usize)],
    user_counts_by_area: &[(u16, String, usize)],
) -> Result<crate::request_response::BootstrapStatusResponse, ApiError> {
    use crate::request_response::{AreaStatusInfo, BidYearStatusInfo, BootstrapStatusResponse};

    // Build bid year summaries
    let bid_years: Vec<BidYearStatusInfo> = metadata
        .bid_years
        .iter()
        .map(|bid_year| {
            let year: u16 = bid_year.year();
            let area_count: usize = area_counts
                .iter()
                .find(|(y, _)| *y == year)
                .map_or(0, |(_, count)| *count);
            let total_user_count: usize = user_counts_by_year
                .iter()
                .find(|(y, _)| *y == year)
                .map_or(0, |(_, count)| *count);

            BidYearStatusInfo {
                year,
                area_count,
                total_user_count,
            }
        })
        .collect();

    // Build area summaries
    let areas: Vec<AreaStatusInfo> = metadata
        .areas
        .iter()
        .map(|(bid_year, area)| {
            let year: u16 = bid_year.year();
            let area_id: String = area.id().to_string();
            let user_count: usize = user_counts_by_area
                .iter()
                .find(|(y, a, _)| *y == year && a == &area_id)
                .map_or(0, |(_, _, count)| *count);

            AreaStatusInfo {
                bid_year: year,
                area_id,
                user_count,
            }
        })
        .collect();

    Ok(BootstrapStatusResponse { bid_years, areas })
}

// ========================================================================
// Authentication Handlers (Phase 14)
// ========================================================================

/// Authenticates an operator and creates a session.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The login request
///
/// # Returns
///
/// * `Ok(LoginResponse)` on success with session token
/// * `Err(ApiError)` if authentication fails
///
/// # Errors
///
/// Returns an error if:
/// - The operator does not exist
/// - The operator is disabled
/// - Database operations fail
pub fn login(
    persistence: &mut SqlitePersistence,
    request: &LoginRequest,
) -> Result<LoginResponse, ApiError> {
    let (session_token, _authenticated_actor, operator): (
        String,
        AuthenticatedActor,
        OperatorData,
    ) = AuthenticationService::login(persistence, &request.login_name, &request.password)?;

    // Get session expiration from the session we just created
    let session: Option<zab_bid_persistence::SessionData> = persistence
        .get_session_by_token(&session_token)
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to retrieve session: {e}"),
        })?;

    let expires_at: String = session
        .ok_or_else(|| ApiError::Internal {
            message: String::from("Session not found after creation"),
        })?
        .expires_at;

    Ok(LoginResponse {
        session_token,
        login_name: operator.login_name,
        display_name: operator.display_name,
        role: operator.role,
        expires_at,
    })
}

/// Logs out by deleting the session.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `session_token` - The session token to delete
///
/// # Errors
///
/// Returns an error if the logout fails.
pub fn logout(persistence: &mut SqlitePersistence, session_token: &str) -> Result<(), ApiError> {
    AuthenticationService::logout(persistence, session_token)?;
    Ok(())
}

/// Returns the current operator's information.
///
/// # Arguments
///
/// * `operator` - The operator data from the validated session
///
/// # Returns
///
/// * `Ok(WhoAmIResponse)` with operator information
#[must_use]
pub fn whoami(operator: &OperatorData) -> WhoAmIResponse {
    WhoAmIResponse {
        login_name: operator.login_name.clone(),
        display_name: operator.display_name.clone(),
        role: operator.role.clone(),
        is_disabled: operator.is_disabled,
    }
}

/// Creates a new operator.
///
/// Only Admin actors may create operators.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The create operator request
/// * `authenticated_actor` - The authenticated actor performing this action
///
/// # Returns
///
/// * `Ok(CreateOperatorResponse)` on success
/// * `Err(ApiError)` if unauthorized or creation fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - The login name already exists
/// - The role is invalid
/// - Database operations fail
pub fn create_operator(
    persistence: &mut SqlitePersistence,
    request: CreateOperatorRequest,
    authenticated_actor: &AuthenticatedActor,
) -> Result<CreateOperatorResponse, ApiError> {
    // Enforce authorization before executing command
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("create_operator"),
            required_role: String::from("Admin"),
        });
    }

    // Validate role
    if request.role != "Admin" && request.role != "Bidder" {
        return Err(ApiError::InvalidInput {
            field: String::from("role"),
            message: format!(
                "Invalid role: {}. Must be 'Admin' or 'Bidder'",
                request.role
            ),
        });
    }

    // Create operator with a default password (should be changed immediately)
    // TODO: This endpoint should require a password in the request
    let operator_id: i64 = persistence
        .create_operator(
            &request.login_name,
            &request.display_name,
            "changeme",
            &request.role,
        )
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to create operator: {e}"),
        })?;

    Ok(CreateOperatorResponse {
        operator_id,
        login_name: request.login_name,
        display_name: request.display_name,
        role: request.role,
    })
}

/// Lists all operators.
///
/// Only Admin actors may list operators.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `authenticated_actor` - The authenticated actor performing this action
///
/// # Returns
///
/// * `Ok(ListOperatorsResponse)` with the list of operators
/// * `Err(ApiError)` if unauthorized or query fails
///
/// # Errors
///
/// Returns an error if:
/// - The actor is not authorized (not an Admin)
/// - Database operations fail
pub fn list_operators(
    persistence: &SqlitePersistence,
    authenticated_actor: &AuthenticatedActor,
) -> Result<ListOperatorsResponse, ApiError> {
    // Enforce authorization before executing command
    if authenticated_actor.role != Role::Admin {
        return Err(ApiError::Unauthorized {
            action: String::from("list_operators"),
            required_role: String::from("Admin"),
        });
    }

    let operators: Vec<OperatorData> =
        persistence
            .list_operators()
            .map_err(|e| ApiError::Internal {
                message: format!("Failed to list operators: {e}"),
            })?;

    let operator_infos: Vec<OperatorInfo> = operators
        .into_iter()
        .map(|op| OperatorInfo {
            operator_id: op.operator_id,
            login_name: op.login_name,
            display_name: op.display_name,
            role: op.role,
            is_disabled: op.is_disabled,
            created_at: op.created_at,
            last_login_at: op.last_login_at,
        })
        .collect();

    Ok(ListOperatorsResponse {
        operators: operator_infos,
    })
}

// ========================================================================
// Bootstrap Authentication (Phase 15)
// ========================================================================

/// Checks whether the system is in bootstrap mode.
///
/// Bootstrap mode is active when no operators exist in the database.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
///
/// # Returns
///
/// * `Ok(BootstrapAuthStatusResponse)` indicating bootstrap status
/// * `Err(ApiError)` if the query fails
///
/// # Errors
///
/// Returns an error if database operations fail.
pub fn check_bootstrap_status(
    persistence: &SqlitePersistence,
) -> Result<crate::BootstrapAuthStatusResponse, ApiError> {
    let operator_count: i64 = persistence
        .count_operators()
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to count operators: {e}"),
        })?;

    Ok(crate::BootstrapAuthStatusResponse {
        is_bootstrap_mode: operator_count == 0,
    })
}

/// Performs bootstrap login with hardcoded credentials.
///
/// This function only succeeds when:
/// - No operators exist in the database (bootstrap mode)
/// - Username is exactly "admin"
/// - Password is exactly "admin"
///
/// The returned token is a temporary bootstrap session, not a real operator session.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The bootstrap login request
///
/// # Returns
///
/// * `Ok(BootstrapLoginResponse)` with a bootstrap token
/// * `Err(ApiError)` if bootstrap mode is not active or credentials are invalid
///
/// # Errors
///
/// Returns an error if:
/// - Operators already exist (not in bootstrap mode)
/// - Credentials are not exactly "admin" / "admin"
/// - Database operations fail
///
/// # Panics
///
/// Panics if the system time is before the Unix epoch.
pub fn bootstrap_login(
    persistence: &SqlitePersistence,
    request: &crate::BootstrapLoginRequest,
) -> Result<crate::BootstrapLoginResponse, ApiError> {
    // Check if we're in bootstrap mode
    let operator_count: i64 = persistence
        .count_operators()
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to count operators: {e}"),
        })?;

    if operator_count > 0 {
        return Err(ApiError::Unauthorized {
            action: String::from("bootstrap_login"),
            required_role: String::from("Bootstrap mode (no operators exist)"),
        });
    }

    // Verify hardcoded credentials
    if request.username != "admin" || request.password != "admin" {
        return Err(ApiError::from(AuthError::AuthenticationFailed {
            reason: String::from("Invalid bootstrap credentials"),
        }));
    }

    // Generate a bootstrap token (simple, temporary)
    let timestamp: u128 = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_nanos();
    let bootstrap_token: String = format!("bootstrap_{timestamp}_{}", rand::random::<u64>());

    Ok(crate::BootstrapLoginResponse {
        bootstrap_token,
        is_bootstrap: true,
    })
}

/// Creates the first admin operator during bootstrap.
///
/// This function only succeeds when:
/// - No operators exist in the database (bootstrap mode)
/// - A valid bootstrap token is provided
///
/// After successful creation, the bootstrap session is terminated and
/// the system transitions out of bootstrap mode.
///
/// # Arguments
///
/// * `persistence` - The persistence layer
/// * `request` - The create first admin request
///
/// # Returns
///
/// * `Ok(CreateFirstAdminResponse)` on success
/// * `Err(ApiError)` if not in bootstrap mode or creation fails
///
/// # Errors
///
/// Returns an error if:
/// - Operators already exist (not in bootstrap mode)
/// - Login name already exists
/// - Password validation fails
/// - Database operations fail
pub fn create_first_admin(
    persistence: &mut SqlitePersistence,
    request: crate::CreateFirstAdminRequest,
) -> Result<crate::CreateFirstAdminResponse, ApiError> {
    // Check if we're in bootstrap mode
    let operator_count: i64 = persistence
        .count_operators()
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to count operators: {e}"),
        })?;

    if operator_count > 0 {
        return Err(ApiError::Unauthorized {
            action: String::from("create_first_admin"),
            required_role: String::from("Bootstrap mode (no operators exist)"),
        });
    }

    // Validate password is not empty
    if request.password.is_empty() {
        return Err(ApiError::InvalidInput {
            field: String::from("password"),
            message: String::from("Password cannot be empty"),
        });
    }

    // Create the first admin operator
    let operator_id: i64 = persistence
        .create_operator(
            &request.login_name,
            &request.display_name,
            &request.password,
            "Admin",
        )
        .map_err(|e| ApiError::Internal {
            message: format!("Failed to create first admin: {e}"),
        })?;

    Ok(crate::CreateFirstAdminResponse {
        operator_id,
        login_name: request.login_name,
        display_name: request.display_name,
        message: String::from("First admin operator created successfully"),
    })
}
