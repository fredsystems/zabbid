// Copyright (C) 2026 Fred Clausen
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

#![deny(
    clippy::pedantic,
    clippy::cargo,
    clippy::nursery,
    clippy::style,
    clippy::correctness,
    clippy::all
)]

use zab_bid::{Command, CoreError, State, TransitionResult, apply};
use zab_bid_audit::{Actor, AuditEvent, Cause};
use zab_bid_domain::{Area, BidYear, Crew, DomainError, Initials, SeniorityData};

/// API request to register a new user for a bid year.
///
/// This DTO is distinct from domain types and represents the API contract.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct RegisterUserRequest {
    /// The bid year (e.g., 2026).
    pub bid_year: u16,
    /// The user's initials.
    pub initials: String,
    /// The user's name.
    pub name: String,
    /// The user's area identifier.
    pub area: String,
    /// The user's crew identifier.
    pub crew: String,
    /// Cumulative NATCA bargaining unit date (ISO 8601).
    pub cumulative_natca_bu_date: String,
    /// NATCA bargaining unit date (ISO 8601).
    pub natca_bu_date: String,
    /// Entry on Duty / FAA date (ISO 8601).
    pub eod_faa_date: String,
    /// Service Computation Date (ISO 8601).
    pub service_computation_date: String,
    /// Optional lottery value.
    pub lottery_value: Option<u32>,
}

/// API response for a successful user registration.
///
/// This DTO is distinct from domain types and represents the API contract.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct RegisterUserResponse {
    /// The bid year the user was registered for.
    pub bid_year: u16,
    /// The user's initials.
    pub initials: String,
    /// The user's name.
    pub name: String,
    /// A success message.
    pub message: String,
}

/// API-level errors.
///
/// These are distinct from domain/core errors and represent the API contract.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ApiError {
    /// A domain rule was violated.
    DomainRuleViolation {
        /// The rule that was violated.
        rule: String,
        /// A human-readable description of the violation.
        message: String,
    },
    /// Invalid input was provided.
    InvalidInput {
        /// The field that was invalid.
        field: String,
        /// A human-readable description of the error.
        message: String,
    },
}

impl std::fmt::Display for ApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DomainRuleViolation { rule, message } => {
                write!(f, "Domain rule violation ({rule}): {message}")
            }
            Self::InvalidInput { field, message } => {
                write!(f, "Invalid input for field '{field}': {message}")
            }
        }
    }
}

impl std::error::Error for ApiError {}

/// Translates a domain error into an API error.
///
/// This translation is explicit and ensures domain errors are not leaked directly.
fn translate_domain_error(err: DomainError) -> ApiError {
    match err {
        DomainError::DuplicateInitials { bid_year, initials } => ApiError::DomainRuleViolation {
            rule: String::from("unique_initials"),
            message: format!(
                "User with initials '{}' already exists in bid year {}",
                initials.value(),
                bid_year.year()
            ),
        },
        DomainError::InvalidInitials(msg) => ApiError::InvalidInput {
            field: String::from("initials"),
            message: msg,
        },
        DomainError::InvalidName(msg) => ApiError::InvalidInput {
            field: String::from("name"),
            message: msg,
        },
        DomainError::InvalidArea(msg) => ApiError::InvalidInput {
            field: String::from("area"),
            message: msg,
        },
        DomainError::InvalidCrew(msg) => ApiError::InvalidInput {
            field: String::from("crew"),
            message: msg,
        },
    }
}

/// The result of an API operation that includes both the response and the audit event.
///
/// This ensures that successful API operations always produce an audit trail.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ApiResult<T> {
    /// The API response.
    pub response: T,
    /// The audit event generated by this operation.
    pub audit_event: AuditEvent,
    /// The new state after the operation.
    pub new_state: State,
}

/// Registers a new user via the API boundary.
///
/// This function:
/// - Translates the API request into a core command
/// - Applies the command to the current state
/// - Translates any errors to API errors
/// - Returns the API response with audit event on success
///
/// # Arguments
///
/// * `state` - The current system state
/// * `request` - The API request to register a user
/// * `actor` - The actor performing this action
/// * `cause` - The cause or reason for this action
///
/// # Returns
///
/// * `Ok(ApiResult<RegisterUserResponse>)` on success
/// * `Err(ApiError)` if the request is invalid or a domain rule is violated
///
/// # Errors
///
/// Returns an error if:
/// - Any field validation fails
/// - The initials are already in use within the bid year
pub fn register_user(
    state: &State,
    request: RegisterUserRequest,
    actor: Actor,
    cause: Cause,
) -> Result<ApiResult<RegisterUserResponse>, ApiError> {
    // Translate API request into domain types
    let bid_year: BidYear = BidYear::new(request.bid_year);
    let initials: Initials = Initials::new(request.initials.clone());
    let area: Area = Area::new(request.area.clone());
    let crew: Crew = Crew::new(request.crew.clone());
    let seniority_data: SeniorityData = SeniorityData::new(
        request.cumulative_natca_bu_date,
        request.natca_bu_date,
        request.eod_faa_date,
        request.service_computation_date,
        request.lottery_value,
    );

    // Create core command
    let command: Command = Command::RegisterUser {
        bid_year: bid_year.clone(),
        initials: initials.clone(),
        name: request.name.clone(),
        area,
        crew,
        seniority_data,
    };

    // Apply command via core transition
    let transition_result: TransitionResult =
        apply(state, command, actor, cause).map_err(|core_err| match core_err {
            CoreError::DomainViolation(domain_err) => translate_domain_error(domain_err),
        })?;

    // Translate to API response
    let response: RegisterUserResponse = RegisterUserResponse {
        bid_year: bid_year.year(),
        initials: initials.value().to_string(),
        name: request.name,
        message: format!(
            "Successfully registered user '{}' for bid year {}",
            initials.value(),
            bid_year.year()
        ),
    };

    Ok(ApiResult {
        response,
        audit_event: transition_result.audit_event,
        new_state: transition_result.new_state,
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_actor() -> Actor {
        Actor::new(String::from("api-user-123"), String::from("api_user"))
    }

    fn create_test_cause() -> Cause {
        Cause::new(String::from("api-req-456"), String::from("API request"))
    }

    fn create_valid_request() -> RegisterUserRequest {
        RegisterUserRequest {
            bid_year: 2026,
            initials: String::from("ABC"),
            name: String::from("John Doe"),
            area: String::from("North"),
            crew: String::from("A"),
            cumulative_natca_bu_date: String::from("2019-01-15"),
            natca_bu_date: String::from("2019-06-01"),
            eod_faa_date: String::from("2020-01-15"),
            service_computation_date: String::from("2020-01-15"),
            lottery_value: Some(42),
        }
    }

    #[test]
    fn test_valid_api_request_succeeds() {
        let state: State = State::new(BidYear::new(2026), Area::new(String::from("North")));
        let request: RegisterUserRequest = create_valid_request();
        let actor: Actor = create_test_actor();
        let cause: Cause = create_test_cause();

        let result: Result<ApiResult<RegisterUserResponse>, ApiError> =
            register_user(&state, request, actor, cause);

        assert!(result.is_ok());
        let api_result: ApiResult<RegisterUserResponse> = result.unwrap();
        assert_eq!(api_result.response.bid_year, 2026);
        assert_eq!(api_result.response.initials, "ABC");
        assert_eq!(api_result.response.name, "John Doe");
        assert!(
            api_result
                .response
                .message
                .contains("Successfully registered")
        );
    }

    #[test]
    fn test_valid_api_request_emits_audit_event() {
        let state: State = State::new(BidYear::new(2026), Area::new(String::from("North")));
        let request: RegisterUserRequest = create_valid_request();
        let actor: Actor = create_test_actor();
        let cause: Cause = create_test_cause();

        let result: Result<ApiResult<RegisterUserResponse>, ApiError> =
            register_user(&state, request, actor, cause);

        assert!(result.is_ok());
        let api_result: ApiResult<RegisterUserResponse> = result.unwrap();
        assert_eq!(api_result.audit_event.action.name, "RegisterUser");
        assert_eq!(api_result.audit_event.actor.id, "api-user-123");
        assert_eq!(api_result.audit_event.cause.id, "api-req-456");
    }

    #[test]
    fn test_valid_api_request_returns_new_state() {
        let state: State = State::new(BidYear::new(2026), Area::new(String::from("North")));
        let request: RegisterUserRequest = create_valid_request();
        let actor: Actor = create_test_actor();
        let cause: Cause = create_test_cause();

        let result: Result<ApiResult<RegisterUserResponse>, ApiError> =
            register_user(&state, request, actor, cause);

        assert!(result.is_ok());
        let api_result: ApiResult<RegisterUserResponse> = result.unwrap();
        assert_eq!(api_result.new_state.users.len(), 1);
        assert_eq!(api_result.new_state.users[0].initials.value(), "ABC");
    }

    #[test]
    fn test_duplicate_initials_returns_api_error() {
        let mut state: State = State::new(BidYear::new(2026), Area::new(String::from("North")));

        // First registration
        let request1: RegisterUserRequest = create_valid_request();
        let actor: Actor = create_test_actor();
        let cause: Cause = create_test_cause();

        let result1: Result<ApiResult<RegisterUserResponse>, ApiError> =
            register_user(&state, request1, actor.clone(), cause.clone());
        assert!(result1.is_ok());
        state = result1.unwrap().new_state;

        // Second registration with same initials
        let request2: RegisterUserRequest = RegisterUserRequest {
            bid_year: 2026,
            initials: String::from("ABC"), // Duplicate
            name: String::from("Jane Smith"),
            area: String::from("South"),
            crew: String::from("B"),
            cumulative_natca_bu_date: String::from("2019-01-15"),
            natca_bu_date: String::from("2019-06-01"),
            eod_faa_date: String::from("2020-01-15"),
            service_computation_date: String::from("2020-01-15"),
            lottery_value: Some(43),
        };

        let result2: Result<ApiResult<RegisterUserResponse>, ApiError> =
            register_user(&state, request2, actor, cause);

        assert!(result2.is_err());
        let err: ApiError = result2.unwrap_err();
        assert!(matches!(err, ApiError::DomainRuleViolation { .. }));
        if let ApiError::DomainRuleViolation { rule, message } = err {
            assert_eq!(rule, "unique_initials");
            assert!(message.contains("ABC"));
            assert!(message.contains("2026"));
        }
    }

    #[test]
    fn test_failed_api_request_does_not_mutate_state() {
        let mut state: State = State::new(BidYear::new(2026), Area::new(String::from("North")));

        // First registration
        let request1: RegisterUserRequest = create_valid_request();
        let actor: Actor = create_test_actor();
        let cause: Cause = create_test_cause();

        let result1: Result<ApiResult<RegisterUserResponse>, ApiError> =
            register_user(&state, request1, actor.clone(), cause.clone());
        assert!(result1.is_ok());
        state = result1.unwrap().new_state;
        let user_count_before: usize = state.users.len();

        // Attempt duplicate registration
        let request2: RegisterUserRequest = RegisterUserRequest {
            bid_year: 2026,
            initials: String::from("ABC"), // Duplicate
            name: String::from("Jane Smith"),
            area: String::from("South"),
            crew: String::from("B"),
            cumulative_natca_bu_date: String::from("2019-01-15"),
            natca_bu_date: String::from("2019-06-01"),
            eod_faa_date: String::from("2020-01-15"),
            service_computation_date: String::from("2020-01-15"),
            lottery_value: Some(43),
        };

        let result2: Result<ApiResult<RegisterUserResponse>, ApiError> =
            register_user(&state, request2, actor, cause);

        assert!(result2.is_err());
        // State should remain unchanged
        assert_eq!(state.users.len(), user_count_before);
    }

    #[test]
    fn test_invalid_empty_initials_returns_api_error() {
        let state: State = State::new(BidYear::new(2026), Area::new(String::from("North")));
        let request: RegisterUserRequest = RegisterUserRequest {
            bid_year: 2026,
            initials: String::new(), // Invalid
            name: String::from("John Doe"),
            area: String::from("North"),
            crew: String::from("A"),
            cumulative_natca_bu_date: String::from("2019-01-15"),
            natca_bu_date: String::from("2019-06-01"),
            eod_faa_date: String::from("2020-01-15"),
            service_computation_date: String::from("2020-01-15"),
            lottery_value: Some(42),
        };
        let actor: Actor = create_test_actor();
        let cause: Cause = create_test_cause();

        let result: Result<ApiResult<RegisterUserResponse>, ApiError> =
            register_user(&state, request, actor, cause);

        assert!(result.is_err());
        let err: ApiError = result.unwrap_err();
        assert!(matches!(err, ApiError::InvalidInput { .. }));
        if let ApiError::InvalidInput { field, message } = err {
            assert_eq!(field, "initials");
            assert!(message.contains("empty"));
        }
    }

    #[test]
    fn test_invalid_empty_name_returns_api_error() {
        let state: State = State::new(BidYear::new(2026), Area::new(String::from("North")));
        let request: RegisterUserRequest = RegisterUserRequest {
            bid_year: 2026,
            initials: String::from("ABC"),
            name: String::new(), // Invalid
            area: String::from("North"),
            crew: String::from("A"),
            cumulative_natca_bu_date: String::from("2019-01-15"),
            natca_bu_date: String::from("2019-06-01"),
            eod_faa_date: String::from("2020-01-15"),
            service_computation_date: String::from("2020-01-15"),
            lottery_value: Some(42),
        };
        let actor: Actor = create_test_actor();
        let cause: Cause = create_test_cause();

        let result: Result<ApiResult<RegisterUserResponse>, ApiError> =
            register_user(&state, request, actor, cause);

        assert!(result.is_err());
        let err: ApiError = result.unwrap_err();
        assert!(matches!(err, ApiError::InvalidInput { .. }));
        if let ApiError::InvalidInput { field, .. } = err {
            assert_eq!(field, "name");
        }
    }

    #[test]
    fn test_invalid_empty_area_returns_api_error() {
        let state: State = State::new(BidYear::new(2026), Area::new(String::from("North")));
        let request: RegisterUserRequest = RegisterUserRequest {
            bid_year: 2026,
            initials: String::from("ABC"),
            name: String::from("John Doe"),
            area: String::new(), // Invalid
            crew: String::from("A"),
            cumulative_natca_bu_date: String::from("2019-01-15"),
            natca_bu_date: String::from("2019-06-01"),
            eod_faa_date: String::from("2020-01-15"),
            service_computation_date: String::from("2020-01-15"),
            lottery_value: Some(42),
        };
        let actor: Actor = create_test_actor();
        let cause: Cause = create_test_cause();

        let result: Result<ApiResult<RegisterUserResponse>, ApiError> =
            register_user(&state, request, actor, cause);

        assert!(result.is_err());
        let err: ApiError = result.unwrap_err();
        assert!(matches!(err, ApiError::InvalidInput { .. }));
        if let ApiError::InvalidInput { field, .. } = err {
            assert_eq!(field, "area");
        }
    }

    #[test]
    fn test_invalid_empty_crew_returns_api_error() {
        let state: State = State::new(BidYear::new(2026), Area::new(String::from("North")));
        let request: RegisterUserRequest = RegisterUserRequest {
            bid_year: 2026,
            initials: String::from("ABC"),
            name: String::from("John Doe"),
            area: String::from("North"),
            crew: String::new(), // Invalid
            cumulative_natca_bu_date: String::from("2019-01-15"),
            natca_bu_date: String::from("2019-06-01"),
            eod_faa_date: String::from("2020-01-15"),
            service_computation_date: String::from("2020-01-15"),
            lottery_value: Some(42),
        };
        let actor: Actor = create_test_actor();
        let cause: Cause = create_test_cause();

        let result: Result<ApiResult<RegisterUserResponse>, ApiError> =
            register_user(&state, request, actor, cause);

        assert!(result.is_err());
        let err: ApiError = result.unwrap_err();
        assert!(matches!(err, ApiError::InvalidInput { .. }));
        if let ApiError::InvalidInput { field, .. } = err {
            assert_eq!(field, "crew");
        }
    }

    #[test]
    fn test_duplicate_initials_in_different_bid_years_allowed() {
        let mut state: State = State::new(BidYear::new(2026), Area::new(String::from("North")));

        // User in 2026
        let request1: RegisterUserRequest = create_valid_request();
        let actor: Actor = create_test_actor();
        let cause: Cause = create_test_cause();

        let result1: Result<ApiResult<RegisterUserResponse>, ApiError> =
            register_user(&state, request1, actor.clone(), cause.clone());
        assert!(result1.is_ok());
        state = result1.unwrap().new_state;

        // Same initials in 2027
        let request2: RegisterUserRequest = RegisterUserRequest {
            bid_year: 2027,                // Different bid year
            initials: String::from("ABC"), // Same initials
            name: String::from("Jane Smith"),
            area: String::from("South"),
            crew: String::from("B"),
            cumulative_natca_bu_date: String::from("2019-01-15"),
            natca_bu_date: String::from("2019-06-01"),
            eod_faa_date: String::from("2020-01-15"),
            service_computation_date: String::from("2020-01-15"),
            lottery_value: Some(43),
        };

        let result2: Result<ApiResult<RegisterUserResponse>, ApiError> =
            register_user(&state, request2, actor, cause);

        assert!(result2.is_ok());
        let api_result: ApiResult<RegisterUserResponse> = result2.unwrap();
        assert_eq!(api_result.new_state.users.len(), 2);
    }

    #[test]
    fn test_api_error_display() {
        let err1: ApiError = ApiError::DomainRuleViolation {
            rule: String::from("test_rule"),
            message: String::from("test message"),
        };
        assert_eq!(
            format!("{err1}"),
            "Domain rule violation (test_rule): test message"
        );

        let err2: ApiError = ApiError::InvalidInput {
            field: String::from("test_field"),
            message: String::from("test error"),
        };
        assert_eq!(
            format!("{err2}"),
            "Invalid input for field 'test_field': test error"
        );
    }

    #[test]
    fn test_successful_api_call_updates_state() {
        let state: State = State::new(BidYear::new(2026), Area::new(String::from("North")));
        assert_eq!(state.users.len(), 0);

        let request: RegisterUserRequest = create_valid_request();
        let actor: Actor = create_test_actor();
        let cause: Cause = create_test_cause();

        let result: Result<ApiResult<RegisterUserResponse>, ApiError> =
            register_user(&state, request, actor, cause);

        assert!(result.is_ok());
        let api_result: ApiResult<RegisterUserResponse> = result.unwrap();

        // New state has the user
        assert_eq!(api_result.new_state.users.len(), 1);
        assert_eq!(api_result.new_state.users[0].name, "John Doe");

        // Original state is unchanged
        assert_eq!(state.users.len(), 0);
    }
}
